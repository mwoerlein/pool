/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace linux;

use sys::core::Class;
use sys::core::Object;
use sys::core::OStream;
use sys::core::Runtime as CoreRuntime;
use sys::runtime::ClassDescriptor;
use sys::runtime::StaticResolvedClassStorage;
use sys::memory::MemoryInfo;
use sys::memory::PageAllocator;

class Runtime extends CoreRuntime, PageAllocator, StaticResolvedClassStorage {

    // TODO: extract allocator
    int heapStart;
    int heapSize;
    int heapHead;
    
    // methods
    global [CoreRuntime] buildRuntime() {
        // get class descriptors
        ClassDescriptor cdClass = Class:_getClassDesc();
        if (!cdClass) { return null; } // abort on initialization error
        
        ClassDescriptor cdRuntime = Runtime:_getClassDesc();
        if (!cdRuntime) { return null; } // abort on initialization error
        
        // allocate spaces
        [int heapStart, int heapSize] = Runtime:_pageAlloc(1024);
        int heapHead = heapStart;

        MemoryInfo icClass = null;
        __pasm__("", {"%eax": heapHead}, {"%eax": icClass});
        icClass.buf = heapHead + MemoryInfo:SIZEOF;
        icClass.len = cdClass.inst_tpl_size;
        icClass.flags = MemoryInfo:FLAGS_USED;
        heapHead = icClass.buf + icClass.len;
        if (!icClass) { return null; } // abort on initialization error

        MemoryInfo irt = null;
        __pasm__("", {"%eax": heapHead}, {"%eax": irt});
        irt.buf = heapHead + MemoryInfo:SIZEOF;
        irt.len = cdRuntime.inst_tpl_size;
        irt.flags = MemoryInfo:FLAGS_USED;
        heapHead = irt.buf + irt.len;
        if (!irt) { return null; } // abort on initialization error
        
        [Class cClass, Object ocClass] = Runtime:_initTemplate(icClass, cdClass);
        [Runtime rt, Object ort] = Runtime:_initTemplate(irt, cdRuntime);
        rt.initHeap(heapStart, heapSize, heapHead);
        return rt._finalizeBootstrap(cClass, cdClass, cdRuntime);
    }
    
    [] __init() {
        LinuxOStream ls1 = this.createInstance(LinuxOStream:CLASSNAME);
        this.setOut(ls1.initOStream(1));
        LinuxOStream ls2 = this.createInstance(LinuxOStream:CLASSNAME);
        FormattedOStream f2 = this.createInstance(FormattedOStream:CLASSNAME);
        this.setErr(f2.initOStream(ls2.initOStream(2)));
    }
    
    [] initHeap(int heapStart, int heapSize, int heapHead) {
        // TODO: extract allocator
        this.heapStart = heapStart;
        this.heapSize = heapSize;
        this.heapHead = heapHead;
    }

    [MemoryInfo] allocate(int size) {
        // TODO: extract allocator
        if (heapHead + MemoryInfo:SIZEOF + size > heapStart + heapSize) {
            return null;
        }
        MemoryInfo info = null;
        __pasm__("", {"%eax": heapHead}, {"%eax": info});
        info.buf = heapHead + MemoryInfo:SIZEOF;
        info.len = size;
        info.flags = MemoryInfo:FLAGS_USED;
        heapHead = info.buf + info.len;
        return info;
    }
    
    [] free(MemoryInfo info) {
        // TODO: extract allocator
    }
    
    [MemoryInfo] allocatePages(int pages) {
        [int start, int size] = Runtime:_pageAlloc(pages);
        MemoryInfo info = null;
        __pasm__("", {"%eax": start}, {"%eax": info});
        info.buf = start;
        info.len = size;
        info.flags = MemoryInfo:FLAGS_AVAILABLE;
        info.next = info.prev = info;
        return info;
    }
    
    [int] isIncreasing() {
        return 0;
    }
    
    // TODO: extract allocator
    global [int, int] _pageAlloc(int pages) {
        int size = pages * MemoryInfo:PAGESIZE;
        int start = 0;
        __pasm__(<"
            pushl 0     // offset
            pushl -1    // fd
            pushl 34    //flags
            pushl 3     // prot
            pushl %eax  // len
            pushl 0     // addr
            movl 90, %eax
            movl %esp, %ebx
            int 0x80 
            addl 24, %esp
        ">, {"%eax": size}, {"%eax": start});
        return [start, size];
    }
    
    global [ClassDescriptor] _getClassDesc() {
        ClassDescriptor desc = null;
        __pasm__("movl 8(%ebp), %eax", {}, {"%eax": desc});
        return desc;
    } 
}
