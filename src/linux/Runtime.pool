/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace linux;

use sys::core::Class;
use sys::core::Object;
use sys::core::OStream;
use sys::core::Runtime as CoreRuntime;
use sys::runtime::ClassDescriptor;
use sys::runtime::MemoryInfo;

class Runtime extends CoreRuntime {

    // TODO: extract allocator
    int heapStart;
    int heapSize;
    int heapHead;
    
    // methods
    global [CoreRuntime] buildRuntime() {
        // get class descriptors
        ClassDescriptor cdClass = Class:_getClassDesc();
        if (!cdClass) { return null; } // abort on initialization error
        
        ClassDescriptor cdRuntime = Runtime:_getClassDesc();
        if (!cdRuntime) { return null; } // abort on initialization error
        
        // allocate spaces
        // TODO: extract allocator
        int heapStart = 0;
        int heapSize = MemoryInfo:PAGESIZE * 1024;
        __pasm__(<"
            pushl 0     // offset
            pushl -1    // fd
            pushl 34    //flags
            pushl 3     // prot
            pushl %eax  // len
            pushl 0     // addr
            movl 90, %eax
            movl %esp, %ebx
            int 0x80 
            addl 24, %esp
        ">, {"%eax": heapSize}, {"%eax": heapStart});
        int heapHead = heapStart;

        MemoryInfo icClass = null;
        __pasm__("", {"%eax": heapHead}, {"%eax": icClass});
        icClass.buf = (heapHead += MemoryInfo:SIZEOF);
        heapHead += (icClass.len = cdClass.inst_tpl_size);
        if (!icClass) { return null; } // abort on initialization error

        MemoryInfo irt = null;
        __pasm__("", {"%eax": heapHead}, {"%eax": irt});
        irt.buf = (heapHead += MemoryInfo:SIZEOF);
        heapHead += (irt.len = cdRuntime.inst_tpl_size);
        if (!irt) { return null; } // abort on initialization error
        
        Class cClass = CoreRuntime:_raw_instantiate(icClass, cdClass);
        Runtime rt = CoreRuntime:_raw_instantiate(irt, cdRuntime);
        rt.initHeap(heapStart, heapSize, heapHead);
        return rt._finalizeBootstrap(cClass, cdClass, cdRuntime);
    }
    
    [] __init() {
        LinuxOStream ls1 = this.createInstance(LinuxOStream:CLASSNAME);
        this.setOut(ls1.initOStream(1));
        LinuxOStream ls2 = this.createInstance(LinuxOStream:CLASSNAME);
        FormattedOStream f2 = this.createInstance(FormattedOStream:CLASSNAME);
        this.setErr(f2.initOStream(ls2.initOStream(2)));
    }
    
    [] initHeap(int heapStart, int heapSize, int heapHead) {
        // TODO: extract allocator
        this.heapStart = heapStart;
        this.heapSize = heapSize;
        this.heapHead = heapHead;
    }

    // TODO: replace int with working class header "struct"
    [ClassDescriptor] getClassDesc(cstring name) {
        int curClass = 0;
        int classesEnd = 0;
        ClassDescriptor classDesc = null;
        __pasm__("movl __classes_start, %eax", {}, {"%eax": curClass});
        __pasm__("movl __classes_end, %eax", {}, {"%eax": classesEnd});
        __pasm__("", {"%eax": curClass}, {"%eax": classDesc});

        // TODO: extract ClassRegistry
        cstring descName = "";
        while ((curClass < classesEnd) && (classDesc.magic == 0x15AC1A55)) {
            __pasm__("addl %ebx, %eax", {"%eax": classDesc, "%ebx": classDesc.classname_offset}, {"%eax": descName});
            if (sys::core::String:compareCStrings(descName, name) == 0) {
                return classDesc;
            }
            curClass += classDesc.class_size;
            __pasm__("", {"%eax": curClass}, {"%eax": classDesc});
        }
        return null;
    }
    
    [MemoryInfo] allocate(int size) {
        // TODO: extract allocator
        if (heapHead + MemoryInfo:SIZEOF + size > heapStart + heapSize) {
            return null;
        }
        MemoryInfo info = null;
        __pasm__("", {"%eax": heapHead}, {"%eax": info});
        info.buf = (heapHead += MemoryInfo:SIZEOF);
        heapHead += (info.len = size);
        return info;
    }
    
    [] free(MemoryInfo info) {
        // TODO: extract allocator
    }
    
    global [ClassDescriptor] _getClassDesc() {
        ClassDescriptor desc = null;
        __pasm__("movl 8(%ebp), %eax", {}, {"%eax": desc});
        return desc;
    } 
}
