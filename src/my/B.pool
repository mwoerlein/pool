/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace my;

use my::core::Thread as myThread;
use my::core::Runtime;
use my::core::Object;

class B extends myThread, my::A {
    
    // methods
    [] run() {
        Runtime rt := this.rt();    // fixed variable
        this.init(7, 20);
        A a := rt.createInstance(A:CLASSNAME);
        a.init(5, 2);
        this.doIt(a);
        rt.destroyInstance(a);
        return;
    }
    
    [] doIt(A a) {
        int out := Runtime:out;    // fixed variable
        Runtime rt := this.rt();    // fixed variable
        rt.printChar('@', Runtime:err);
        rt.printString("OMG!! ", out);
        rt.printInt(this.equals(this), out);
        rt.printChar(' ', out);
        rt.printInt(this.equals(a), out);
        this.testAllocate(0x1234);
        rt.printChar('@', Runtime:err);
        rt.printChar('\n', out);
        this.testLoop(4);
//        this.testLoop(13);
        this.test(this.getRow());
        a.test(a.getRow());
        return;
    }
    
    [] testLoop(int n) {
        int out = Runtime:out;      // modifiable variable
        Runtime rt := this.rt();    // fixed variable
        int i = n;
        while (i--) {
            int j = n;
            while (j--) {
                if (n>=10) {
                    if (i==j || i+j==n-1) {
                        out = Runtime:err;
                    } else {
                        out = Runtime:out;
                    }
                    if (i<10) {
                        rt.printChar(' ', out);
                    }
                } else {
                    if (i<=j) {
                        out = Runtime:out;
                    } else {
                        out = Runtime:err;
                    }
                }
                rt.printInt(i, out);
                rt.printChar(' ', out);
                rt.printInt(j, out);
                if (j) {
                    rt.printChar(' ', out);
                    rt.printChar(' ', out);
                }
            }
            rt.printChar('\n', out);
        }
    }
    
    [] testAllocate(int size) {
        int out := Runtime:out;     // fixed variable
        Runtime rt := this.rt();    // fixed variable
        // TODO: replace int with working MemInfo "struct"
        int mem := rt.allocate(size);
        rt.printChar(' ', out);
        rt.printHex(mem, out);
        rt.printChar(' ', out);
        rt.printHex(0xdead, out);
//        rt.printHex(mem.buffer, out);
        rt.printChar(' ', out);
        rt.printHex(0xc0de, out);
//        rt.printHex(mem.size, out);
        rt.free(mem);
        return;
    }
    
    [int] getRow() {
        return 2*row;
    }
    
}
