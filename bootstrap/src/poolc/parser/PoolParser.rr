#include "poolc/parser/PoolParser.hpp"

#include "sys/Digit.hpp"

#include "Parser.h"
#define SIZE 5000

/*!stags:re2c format = 'char *@@;'; */
/*!max:re2c*/

// public
PoolParser::PoolParser(Environment &env, MemoryInfo &mi):ParseBuffer(env, mi, SIZE, YYMAXFILL), Object(env, mi), input(0), cls(0) {}
PoolParser::~PoolParser() {}

ClassDefNode * PoolParser::parse(IStream &input) {
    this->input = &input;
    
    Parser parser(*this);
    if (parser.parse()) {
        return 0;
    }
    
    return cls;
}

int PoolParser::parseIntegerValue(char * start, char * end, int base) {
    int result = 0;
    Digit d(env());
    while (start < end) {
        d = *start++;
        result *= base;
        result += (int) d;
    }
    return result;
}

String * PoolParser::parseString(char enclosure) {
    String &s = env().create<String>();
    int startLine = linesBuffer[current-buffer];
    int startColumn = columnsBuffer[current-buffer];
    for (;;) {
        char * tok = current;
/*!re2c
        re2c:flags:T = 1;
        re2c:define:YYCTYPE = char;
        
        re2c:define:YYCURSOR = current;
        re2c:define:YYMARKER = marker;
        re2c:define:YYCTXMARKER = ctxmarker;
        re2c:define:YYLIMIT = limit;
        re2c:yyfill:enable = 1;
        re2c:define:YYFILL = "if (!fillBuffer(@@, *input)) break;";
        re2c:define:YYFILL:naked = 1;
        
        *                    { break; }
        [^\n\\]              { if (enclosure == *tok) { return &s; }; s << *tok; continue; }
        "\\n"                { s << '\n'; continue; }
        "\\r"                { s << '\r'; continue; }
        "\\t"                { s << '\t'; continue; }
        "\\\\"               { s << '\\'; continue; }
        "\\'"                { s << '\''; continue; }
        "\\\""               { s << '"';  continue; }
*/
    }
    env().err() << "unterminated string '" << s << "' at line: " << startLine << " column: "  << startColumn << '\n';
    s.destroy();
    return 0;
}

int PoolParser::lex(Parser & parser)
{
    char *o1, *o2;
    for (;;) {
        token = current;
/*!re2c
        re2c:flags:T = 1;
        re2c:define:YYCTYPE = char;
        
        re2c:define:YYCURSOR = current;
        re2c:define:YYMARKER = marker;
        re2c:define:YYCTXMARKER = ctxmarker;
        re2c:define:YYLIMIT = limit;
        re2c:yyfill:enable = 1;
        re2c:define:YYFILL = "if (!fillBuffer(@@, *input)) return 0;";
        re2c:define:YYFILL:naked = 1;
        
        end         = "\x00";
        eol         = "\r"? "\n" | "\r";
        wsp         = [ \t]*;
        id          = [a-zA-Z_][a-zA-Z0-9_]*;
        
        ","         { return ','; }
        ";"         { return ';'; }
        "="         { return '='; }
        "<"         { return '<'; }
        ">"         { return '>'; }
        "{"         { return '{'; }
        "}"         { return '}'; }
        "("         { return '('; }
        ")"         { return ')'; }
        
        "class"     { return parser.makeClass(); }
        "extends"   { return parser.makeExtends(); }
        "local"     { return parser.makeLocal(); }
        "global"    { return parser.makeGlobal(); }
        "abstract"  { return parser.makeAbstract(); }
        "__naked__" { return parser.makeNaked(); }
        
        "0" [bB] @o1 [01]+ @o2          { return parser.makeNumber( parseIntegerValue(o1, o2,  2)); }
        "-0" [bB] @o1 [01]+ @o2         { return parser.makeNumber(-parseIntegerValue(o1, o2,  2)); }
        "0" @o1 [0-7]+ @o2              { return parser.makeNumber( parseIntegerValue(o1, o2,  8)); }
        "-0" @o1 [0-7]+ @o2             { return parser.makeNumber(-parseIntegerValue(o1, o2,  8)); }
        @o1 [1-9][0-9]* @o2             { return parser.makeNumber( parseIntegerValue(o1, o2, 10)); } 
        "-" @o1 [1-9][0-9]* @o2         { return parser.makeNumber(-parseIntegerValue(o1, o2, 10)); } 
        "0"[xX] @o1 [0-9a-fA-F]+ @o2    { return parser.makeNumber( parseIntegerValue(o1, o2, 16)); }
        "-0"[xX] @o1 [0-9a-fA-F]+ @o2   { return parser.makeNumber(-parseIntegerValue(o1, o2, 16)); }
        "-"? "0"                        { return parser.makeNumber(0); }
        
        @o1 ['"]    {
                        String *s = parseString(*o1);
                        if (!s) break;
                        return parser.makeString(*s);
                    }
        
        @o1 id @o2  {
                        String &s = env().create<String, char *, char *>(o1, o2);
                        return parser.makeID(s);
                    }
        
        "//" @o1 [^\n]* @o2 eol { continue; }
        "/*" @o1 ([^*] | ("*" [^/]))* @o2 "*""/" { continue; }
        eol         { continue; }
        wsp         { continue; }
        end         { return 0; }
        *           { break; }
*/
    }
    env().err() << "unexpected character : " << *token
        << " line: " << linesBuffer[token-buffer]
        << " column: "  << columnsBuffer[token-buffer]
        << '\n';
    return -1;
}


bool PoolParser::error(const char* msg) {
    env().err()<<msg<<"\n";
    return true;
}

void PoolParser::shift(size_t freed) {
    /*!stags:re2c format = "@@ -= freed;\n"; */
}
