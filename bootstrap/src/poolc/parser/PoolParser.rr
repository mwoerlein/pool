#include "poolc/parser/PoolParser.hpp"

#include "sys/Digit.hpp"

#include "Parser.h"
#define SIZE 500

/*!stags:re2c format = 'char *@@;'; */
/*!max:re2c*/
/*!re2c
        re2c:flags:T = 1;
        re2c:define:YYCTYPE = char;
        
        re2c:define:YYCURSOR = current;
        re2c:define:YYMARKER = marker;
        re2c:define:YYCTXMARKER = ctxmarker;
        re2c:define:YYLIMIT = limit;
        re2c:yyfill:enable = 1;
        re2c:define:YYFILL = "if (!fillBuffer(@@, *input)) return 0;";
        re2c:define:YYFILL:naked = 1;
        
        end         = "\x00";
        eol         = "\r"? "\n" | "\r";
        wsp         = [ \t]*;
        id          = [a-zA-Z_][a-zA-Z0-9_]*;
*/

// public
PoolParser::PoolParser(Environment &env, MemoryInfo &mi):ParseBuffer(env, mi, SIZE, YYMAXFILL), Object(env, mi), input(0), unit(0), parser(0) {}
PoolParser::~PoolParser() {}

TranslationUnitNode * PoolParser::parse(IStream &input, String & name) {
    resetBuffer();
    TranslationUnitNode &unit = env().create<TranslationUnitNode>();
    unit.name = name;
    Parser parser(*this);
     
    this->input = &input;
    this->unit = &unit;
    this->parser = &parser;
    
    int parseResult = parser.parse(); 
    this->input = 0;
    this->unit = 0;
    this->parser = 0;
    
    if (parseResult) {
        unit.destroy();
        return 0;
    }

    return &unit;
}

TranslationUnitNode * PoolParser::getUnit() {
    return unit;
}

void PoolParser::setLocation() {
    parser->setLocation(getLine(token), getColumn(token), getLine(current), getColumn(current));
}

int PoolParser::parseIntegerValue(char * start, char * end, int base) {
    int result = 0;
    Digit d(env());
    while (start < end) {
        d = *start++;
        result *= base;
        result += (int) d;
    }
    return result;
}

String * PoolParser::readString(char enclosure) {
    String &s = env().create<String>();
    int startLine = getLine(current);
    int startColumn = getColumn(current);
    for (;;) {
        token = current;
/*!re2c
        *           { break; }
        [^\r\n\\]   { if (enclosure == *token) { return &s; }; s << *token; continue; }
        "\\n"       { s << '\n'; continue; }
        "\\r"       { s << '\r'; continue; }
        "\\t"       { s << '\t'; continue; }
        "\\\\"      { s << '\\'; continue; }
        "\\'"       { s << '\''; continue; }
        "\\\""      { s << '"';  continue; }
*/
    }
    env().err() << "unterminated string '" << s << "' at line: " << startLine << " column: "  << startColumn << '\n';
    s.destroy();
    return 0;
}

String * PoolParser::readMultilineString() {
    String &s = env().create<String>();
    int startLine = getLine(current);
    int startColumn = getColumn(current);
    for (;;) {
        token = current;
/*!re2c
        end             { break; }
        eol wsp ["] ">" { return &s; }
        *               { if (startLine != getLine(token)) { s << *token; } continue; }
*/
    }
    env().err() << "unterminated multiline string '" << s << "' at line: " << startLine << " column: "  << startColumn << '\n';
    s.destroy();
    return 0;
}

String * PoolParser::readComment() {
    String &s = env().create<String>();
    int startLine = getLine(current);
    int startColumn = getColumn(current);
    for (;;) {
        token = current;
/*!re2c
        end     { break; }
        "*" "/" { return &s; }
        *       { s << *token; continue; }
*/
    }
    env().err() << "unterminated comment '" << s << "' at line: " << startLine << " column: "  << startColumn << '\n';
    s.destroy();
    return 0;
}

String * PoolParser::readLine() {
    String &s = env().create<String>();
    for (;;) {
        token = current;
/*!re2c
        end     { break; }
        eol     { break; }
        *       { s << *token; continue; }
*/
    }
    return &s;
}

int PoolParser::lex()
{
    char *o1, *o2;
    for (;;) {
        token = current;
/*!re2c
        ","         { setLocation(); return ','; }
        ";"         { setLocation(); return ';'; }
        "="         { setLocation(); return '='; }
        "<"         { setLocation(); return '<'; }
        ">"         { setLocation(); return '>'; }
        "{"         { setLocation(); return '{'; }
        "}"         { setLocation(); return '}'; }
        "("         { setLocation(); return '('; }
        ")"         { setLocation(); return ')'; }
        
        ":="            { setLocation(); return parser->makeColonEqual(); }
        
        "abstract"      { setLocation(); return parser->makeAbstract(); }
        "as"            { setLocation(); return parser->makeAs(); }
        "class"         { setLocation(); return parser->makeClass(); }
        "extends"       { setLocation(); return parser->makeExtends(); }
        "global"        { setLocation(); return parser->makeGlobal(); }
        "namespace"     { setLocation(); return parser->makeNamespace(); }
        "use"           { setLocation(); return parser->makeUse(); }
        
        "__bootstrap__" { setLocation(); return parser->makeBootstrap(); }
        "__naked__"     { setLocation(); return parser->makeNaked(); }
        "__pasm__"      { setLocation(); return parser->makePasm(); }
        
        "0" [bB] @o1 [01]+ @o2          { setLocation(); return parser->makeNumber( parseIntegerValue(o1, o2,  2)); }
        "-0" [bB] @o1 [01]+ @o2         { setLocation(); return parser->makeNumber(-parseIntegerValue(o1, o2,  2)); }
        "0" @o1 [0-7]+ @o2              { setLocation(); return parser->makeNumber( parseIntegerValue(o1, o2,  8)); }
        "-0" @o1 [0-7]+ @o2             { setLocation(); return parser->makeNumber(-parseIntegerValue(o1, o2,  8)); }
        @o1 [1-9][0-9]* @o2             { setLocation(); return parser->makeNumber( parseIntegerValue(o1, o2, 10)); } 
        "-" @o1 [1-9][0-9]* @o2         { setLocation(); return parser->makeNumber(-parseIntegerValue(o1, o2, 10)); } 
        "0"[xX] @o1 [0-9a-fA-F]+ @o2    { setLocation(); return parser->makeNumber( parseIntegerValue(o1, o2, 16)); }
        "-0"[xX] @o1 [0-9a-fA-F]+ @o2   { setLocation(); return parser->makeNumber(-parseIntegerValue(o1, o2, 16)); }
        "-"? "0"                        { setLocation(); return parser->makeNumber(0); }
        
        @o1 id ("::" id)+ @o2  {
                        String &s = env().create<String, char *, char *>(o1, o2);
                        setLocation();
                        return parser->makeFullQualifiedName(s);
                    }
        @o1 id @o2  {
                        String &s = env().create<String, char *, char *>(o1, o2);
                        setLocation();
                        return parser->makeID(s);
                    }
        
        @o1 ['"]    {
                        String *s = readString(*o1); if (!s) break;
                        setLocation();
                        return parser->makeString(*s);
                    }
        "<" ["] wsp / eol {
                        String *s = readMultilineString(); if (!s) break;
                        setLocation();
                        return parser->makeString(*s);
                    }
        
        "//"        {
                        String *s = readLine(); if (!s) break;
                        s->destroy(); continue;
                    }
        "/*"        {
                        String *s = readComment(); if (!s) break;
                        s->destroy(); continue;
                    }
        "/**"       {
                        String *s = readComment(); if (!s) break;
                        s->destroy(); continue;
                    }
        
        eol         { continue; }
        wsp         { continue; }
        end         { return 0; }
        *           { break; }
*/
    }
    env().err() << "unexpected character : " << *token
        << " line: " << getLine(token)
        << " column: "  << getColumn(token)
        << '\n';
    return -1;
}


bool PoolParser::error(const char* msg, int line, int column) {
    OStream & err = env().err();
    if (unit) {
        err << unit->name << ": ";
    }
    err << msg;
    if (line >= 0) {
        err << " (at l" << line << ":c" << column << ")";
    }
    err << "\n";
    return true;
}

void PoolParser::shift(size_t freed) {
    /*!stags:re2c format = "@@ -= freed;\n"; */
}
