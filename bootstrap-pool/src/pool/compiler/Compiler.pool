/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace pool::compiler;

use pool::asm::Parser as AsmParser;
use pool::asm::CompilationUnit as AsmUnit;
use pool::asm::i386::Compiler as AsmCompiler;

use pool::compiler::ast::NamedType;
use pool::compiler::ast::node::declaration::ClassDeclNode;
use pool::compiler::ast::node::declaration::StructDeclNode;
use pool::compiler::ast::node::declaration::TranslationUnitNode;
use pool::compiler::ast::visitor::InstructionResolver;
use pool::compiler::ast::visitor::PrettyPrinter;
use pool::compiler::ast::visitor::SignatureResolver;
use pool::compiler::ast::visitor::TypeReferenceResolver;
use pool::compiler::parser::Parser;
use pool::storage::ClassPathStorage;
use pool::storage::PoolStorage;

use sys::core::String;
use sys::core::anycollection::AnyList;
use sys::core::anycollection::AnyIterator;
use sys::core::anycollection::AnyMapEntryIterator;
use sys::log::Logger;
use sys::store::StorageElement;
use sys::stream::IStream;
use sys::stream::OStream;

class Compiler extends pool::compiler::ast::TypeManager {

    ClassPathStorage classPath;
    PoolStorage out;
    Parser parser;
    PrettyPrinter pp;
    TypeReferenceResolver resolveTypeRefs;
    SignatureResolver resolveSignature;
    InstructionResolver resolveInstructions;
    AnyList preparedUnits; // LinkedList<TranslationUnitNode>
    
    [] __init() {
        this._initTypeManager();
        parser = this.createOwn(Parser:CLASSNAME);
        classPath = this.createOwn(ClassPathStorage:CLASSNAME);
        preparedUnits = this.createOwn(AnyList:CLASSNAME);
        resolveTypeRefs = this.createOwn(TypeReferenceResolver:CLASSNAME);
        resolveTypeRefs.setTypeManager(this.typeManager());
        resolveSignature = this.createOwn(SignatureResolver:CLASSNAME);
        resolveInstructions = this.createOwn(InstructionResolver:CLASSNAME);
    }
    [Compiler] initLogger(Logger logger) {
        this.setLogger(logger);
        parser.setLogger(logger);
        resolveTypeRefs.setLogger(logger);
        resolveSignature.setLogger(logger);
        resolveInstructions.setLogger(logger);
        if (pp) { pp.setLogger(logger); }
        return this;
    }
    
    [Compiler] addClassPath(PoolStorage pool) { classPath.add(this.own(pool)); return this; }
    [Compiler] setOutput(PoolStorage pool) { out = this.own(pool); return this; }
    [Compiler] setPrettyOutput(PoolStorage pool) {
        pp = this.createOwn(PrettyPrinter:CLASSNAME);
        pp.setStorage(pool);
        if (this.getLogger()) { pp.setLogger(this.getLogger()); }
        return this;
    }
    
    [int] hasErrors() { return logger.has(Logger:ERROR); }
    
    [] prepare(String fqn) {
        NamedType type = _namedTypes.get(fqn);
        if (type) {
            // reuse already initialized unit
            preparedUnits.add(type.getUnitNode());
        } else {
            TranslationUnitNode unit = this._initializeUnit(fqn);
            if (unit) { preparedUnits.add(unit); } else { this._failUnit(fqn); }
        }
    }
    
    [] skip(String fqn) {
        this.notice().print(fqn).printCString(" skipped");
    }
    
    [] compilePrepared() {
        AnyIterator it = preparedUnits.iterator();
        while (!this.hasErrors() && it.hasNext()) {
            TranslationUnitNode unit = it.next();
            AnyIterator cit = unit.getClasses().iterator();
            while (!this.hasErrors() && cit.hasNext()) {
                ClassDeclNode cd = cit.next();
                if (!this._compileClass(unit.getName(), cd)) { this._failUnit(unit.getName()); }
            }
            cit.destroy();
        }
        it.destroy();
    }
    
    [] compileAll() {
        AnyMapEntryIterator it = _namedTypes.entries();
        while (!this.hasErrors() && it.hasNext()) {
            [String fqn, NamedType t] := it.nextPair();
            ClassDeclNode cd = t.getClassDeclNode();
            if (cd && !this._compileClass(fqn, cd)) { this._failUnit(cd.getName()); }
        }
        it.destroy();
    }
    
    [] compileStatic(OStream stream, String binding, int startAddress) {
        StorageElement header = classPath.getHeader(binding);
        if (!header) {
            this.error().printCString("invalid binding '").print(binding).printCString("'");
            return;
        }
        StorageElement footer = classPath.getFooter(binding);
        if (!footer) {
            header.destroy();
            this.error().printCString("invalid binding '").print(binding).printCString("'");
            return;
        }
    
        AsmParser parser = this.createOwn(AsmParser:CLASSNAME);
        AsmCompiler compiler = this.createOwn(AsmCompiler:CLASSNAME);
        AsmUnit unit = this.createOwn(AsmUnit:CLASSNAME);
    
        this.pushComment(unit).printCString("binding: '").print(binding).printChar('\'');
        this.pushComment(unit).printCString("startAddress: ").printPtr(startAddress);
        
        { // parse header
            IStream in = header.getContent();
            parser.parse(in, binding, unit);
            in.destroy();
            header.destroy();
        }
        
        { // compile classes
            this.fakeEntry(unit);
            AnyMapEntryIterator it = _namedTypes.entries();
            while (!this.hasErrors() && it.hasNext()) {
                [String fqn, NamedType t] := it.nextPair();
                this.pushComment(unit).printCString("TODO: compile class '").print(fqn).printCString("'");
                // TODO: compile class and append to unit/nodes
            }
            it.destroy();
        }
        
        { // parse footer
            IStream in = footer.getContent();
            parser.parse(in, binding, unit);
            in.destroy();
            footer.destroy();
        }
        
        // compile assembly
        // TODO handle/display pasm errors
        if (unit.hasErrors()) {
            this.error().printCString("asm generation failed!");
        } else {
            compiler.prepare(unit);
            if (unit.hasErrors()) {
                this.error().printCString("asm preparation failed!");
            } else {
                compiler.compile(unit);
                if (unit.hasErrors()) {
                    this.error().printCString("asm compilation failed!");
                } else {
                    compiler.finalize(unit, startAddress);
                    if (unit.hasErrors()) {
                        this.error().printCString("asm finalization failed!");
                    } else {
                        //stream.print(nodes);
                        unit.rawToStream(stream);
                    }
                }
            }
        }
                
        unit.destroy();
        compiler.destroy();
        parser.destroy();
    }
    
    [OStream] pushComment(AsmUnit unit) {
        pool::asm::ast::CommentNode comment = this.rt().createInstance(pool::asm::ast::CommentNode:CLASSNAME);
        unit.getNodeList().add(comment.node());
        return comment.getComment().ostream();
    }
    
    [] fakeEntry(AsmUnit unit) {
        {
            pool::asm::ast::DefinitionNode entryClass = this.rt().createInstance(pool::asm::ast::DefinitionNode:CLASSNAME);
            pool::asm::ast::operand::NumberNode value = this.rt().createInstance(pool::asm::ast::operand::NumberNode:CLASSNAME);
            String id = entryClass.createOwn(String:CLASSNAME);
            id.assignCString("_entry_class_desc");
            entryClass.initDefinition(id, value.operand());
            unit.getNodeList().add(entryClass.node());
        }
        {
            pool::asm::ast::LabelNode entryLabel = this.rt().createInstance(pool::asm::ast::LabelNode:CLASSNAME);
            String label = entryLabel.createOwn(String:CLASSNAME);
            label.assignCString("_entry_global_func");
            entryLabel.setLabel(label);
            unit.getNodeList().add(entryLabel.node());
        }
        {
            pool::asm::ast::InstructionNode retNode = this.rt().createInstance(pool::asm::ast::InstructionNode:CLASSNAME);
            String ret = retNode.createOwn(String:CLASSNAME);
            ret.assignCString("ret");
            retNode.setOperation(ret);
            unit.getNodeList().add(retNode.node());
        }
    }
    
    [NamedType] getNamedType(String fqn) {
        if (!_namedTypes.has(fqn) && !this._initializeUnit(fqn)) {
            return null;
        }
        return _namedTypes.get(fqn);
    }
    
    [TranslationUnitNode] _initializeUnit(String fqn) {
        this.info().printCString("initialize ").print(fqn);
        StorageElement elem = classPath.getSourceClass(fqn);
        if (!elem) {
            this.error().printCString("declaration of '").print(fqn).printCString("' not found!");
            return null;
        }
        TranslationUnitNode unit = this.createOwn(TranslationUnitNode:CLASSNAME);
        this._debugStep(fqn, "parse");
        parser.parse(unit.init(elem, fqn));
        if (this.hasErrors()) { unit.destroy(); return null; }
        
        if (pp) {
            this._debugStep(fqn, "pretty print parsed");
            pp.visit(unit.node());
        }
        
        this._debugStep(fqn, "resolve type references");
        resolveTypeRefs.visit(unit.node());
        
        return unit;
    }
    
    [int] _compileClass(String fqn, ClassDeclNode node) {
        this.notice().printCString("compile ").print(fqn);
        
        this._debugStep(fqn, "resolve signature");
        resolveSignature.visit(node.node());
        if (this.hasErrors()) { return false; }
        
        this._debugStep(fqn, "resolve instructions");
        resolveInstructions.visit(node.node());
        if (this.hasErrors()) { return false; }
/*        
        this._debugStep(fqn, "generate PIR");
        generatePIR.visit(node.node());
        if (this.hasErrors()) { return false; }
        
        this._debugStep(fqn, "generate PASM");
        generatePASMUnit.visit(node.node());
        if (this.hasErrors()) { return false; }
        
        // TODO: print PASM
        // or
        // TODO: compile PASM
        // TODO: print binary
        
        if (pp) {
            this._debugStep(fqn, "pretty print compiled");
            pp.visit(node.getScope().getUnitNode().node());
        }
*/
        if (this.hasErrors()) { return false; }
        return true;
    }
    
    [] _failUnit(String fqn) {
        this.error().print(fqn).printCString(" failed");
    }
    
    [] _debugStep(String fqn, cstring step) {
        if (!this.hasLogLevel(sys::log::Logger:DEBUG)) { return; }
        this.debug().printChar(' ').printChar(' ').print(fqn).printChar(':').printChar(' ').printCString(step);
    }
}
