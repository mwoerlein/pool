/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace pool::compiler;

use pool::compiler::ast::Node;
use pool::compiler::ast::node::declaration::ClassDeclNode;
use pool::compiler::ast::node::declaration::StructDeclNode;
use pool::compiler::ast::node::declaration::TranslationUnitNode;
use pool::compiler::ast::visitor::PrettyPrinter;
use pool::compiler::parser::Parser;
use pool::storage::ClassPathStorage;
use pool::storage::PoolStorage;

use sys::core::String;
use sys::core::anycollection::AnyList;
use sys::core::anycollection::AnyIterator;
use sys::log::Logger;
use sys::log::LoggerAware;
use sys::store::StorageElement;
use sys::stream::OStream;

class Compiler extends LoggerAware {

    ClassPathStorage classPath;
    PoolStorage out;
    Parser parser;
    PrettyPrinter pp;
    AnyList units; // LinkedList<TranslationUnitNode>
    AnyList classes; // LinkedList<ClassDeclNode>
    AnyList structs; // LinkedList<StructDeclNode>
    
    [] __init() {
        parser = this.createOwn(Parser:CLASSNAME);
        classPath = this.createOwn(ClassPathStorage:CLASSNAME);
        units = this.createOwn(AnyList:CLASSNAME);
        classes = this.createOwn(AnyList:CLASSNAME);
        structs = this.createOwn(AnyList:CLASSNAME);
    }
    [Compiler] initLogger(Logger logger) {
        this.setLogger(logger);
        parser.setLogger(logger);
        return this;
    }
    
    [Compiler] addClassPath(PoolStorage pool) { classPath.add(this.own(pool)); return this; }
    [Compiler] setOutput(PoolStorage pool) { out = this.own(pool); return this; }
    [Compiler] setPrettyOutput(PoolStorage pool) {
        pp = this.createOwn(PrettyPrinter:CLASSNAME);
        pp.setStorage(pool);
        return this;
    }
    
    [int] hasErrors() { return logger.has(Logger:ERROR); }
    
    [] prepare(String fqn) {
        TranslationUnitNode unit = this._initialize(fqn);
        if (unit) { units.add(units.own(unit)); } else { this._failUnit(fqn); }
    }
    
    [] skip(String fqn) {
        this.note().print(fqn).printCString(" skipped");
    }
    
    [] compilePrepared() {
        AnyIterator it = units.iterator();
        while (!this.hasErrors() && it.hasNext()) {
            TranslationUnitNode unit = it.next();
            if (!this._compile(unit.getName(), unit.node())) { this._failUnit(unit.getName()); }
        }
        it.destroy();
    }
    
    [] compileAll() {
        int success = true;
        AnyIterator it = classes.iterator();
        while (!this.hasErrors() && it.hasNext()) {
            ClassDeclNode cd = it.next();
            // TODO: use full qualified name of class
            if (!this._compile(cd.getName(), cd.node())) { this._failUnit(cd.getName()); }
        }
        it.destroy();
    }
    
    [TranslationUnitNode] _initialize(String fqn) {
        this.info().printCString("initialize ").print(fqn);
        StorageElement elem = classPath.getSourceClass(fqn);
        if (!elem) {
            this.error().printCString("declaration of '").print(fqn).printCString("' not found!");
            return null;
        }
        TranslationUnitNode unit = this.rt().createInstance(TranslationUnitNode:CLASSNAME);
        this._debugStep(fqn, "parse");
        parser.parse(unit.init(elem, fqn));
        if (this.hasErrors()) { unit.destroy(); return null; }
        
        this._debugStep(fqn, "pretty print");
        if (pp) { pp.visit(unit.node()); }
/*        
        this._debugStep(fqn, "resolve type references");
        resolveTypeRefs.visit(unit.node());
*/
        return unit;
    }
    
    [int] _compile(String fqn, Node node) {
        this.note().printCString("compile ").print(fqn);
/*        
        this._debugStep(fqn, "resolve methods");
        resolveMethods.visit(node);
        if (this.hasErrors()) { return false; }
        
        this._debugStep(fqn, "resolve instructions");
        resolveInstructions.visit(node);
        if (this.hasErrors()) { return false; }
        
        this._debugStep(fqn, "generate PIR");
        generatePIR.visit(node);
        this._debugStep(fqn, "generate binary");
        generatePASM.visit(node);
        if (this.hasErrors()) { return false; }
        
        this._debugStep(fqn, "pretty print");
        if (pp) { pp.visit(node.getUnitNode()); }
*/
        if (this.hasErrors()) { return false; }
        return true;
    }
    
    [] _failUnit(String fqn) {
        this.error().print(fqn).printCString(" failed");
    }
    
    [] _debugStep(String fqn, cstring step) {
        this.debug().printChar(' ').printChar(' ').print(fqn).printChar(':').printChar(' ').printCString(step);
    }
}
