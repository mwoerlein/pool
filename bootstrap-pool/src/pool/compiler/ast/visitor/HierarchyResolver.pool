/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace pool::compiler::ast::visitor;

use pool::compiler::ast::Visitor;

use pool::compiler::ast::node::declaration::ClassDeclNode;
use pool::compiler::ast::node::declaration::StructDeclNode;
use pool::compiler::ast::node::declaration::TranslationUnitNode;

use pool::compiler::ast::node::reference::ClassRefNode;
use pool::compiler::ast::node::reference::TypeRefNode;

use pool::compiler::ast::Scope;
use pool::compiler::ast::scope::ClassScope;
use pool::compiler::ast::scope::StructScope;

use sys::core::anycollection::AnyIterator;

class HierarchyResolver extends Visitor {

    Scope _curScope;
    
    // declarations
    [int] visitTranslationUnit(TranslationUnitNode node) {
        this.crit().print(node.getName()).printCString(": HierarchyResolver only works for classes/structs, not for translation units!");
        return false;
    }
    
    [int] visitClassDecl(ClassDeclNode node) {
        Scope tmpScope := _curScope;
        ClassScope cs := node.getClassScope();
        if (!cs || cs.getState() < Scope:STATE_TYPE_REFERENCES_RESOLVED) {
            this.error().print(node.getName()).printCString(": references must be resolved before resolving hierarchy!");
            _curScope = tmpScope;
            return false;
        }
        if (cs.getState() >= Scope:STATE_RESOLVING_HIERARCHY) {
            return true;
        }
        _curScope = cs.scope();
        cs.setState(Scope:STATE_RESOLVING_HIERARCHY);
        this._traceStart(cs.getFullQualifiedName(), "resolving class hierarchy");
        
        {
            AnyIterator it = node.getExtends().iterator();
            while (it.hasNext()) {
                TypeRefNode typeNode = it.next();
                typeNode.accept(this.visitor()); // ensure complete hierarchy of extended class
                ClassScope extendedClassScope := this.rt().cast(ClassScope:CLASSNAME, typeNode.getResolvedType());
                if (extendedClassScope) {
                    if (extendedClassScope.getState() < Scope:STATE_RESOLVING_HIERARCHY) {
                        this.error().print(cs.getFullQualifiedName()).printCString(": cyclic class hierarchy detected! (unfinished ").print(typeNode).printChar(')');
                    } else {
                        AnyIterator sit = extendedClassScope.getSupers();
                        while (sit.hasNext()) { cs.addSuper(sit.next()); }
                        sit.destroy();
                    }
                } else {
                    this.error().print(cs.getFullQualifiedName()).printCString(": invalid super type '").print(typeNode).printChar('"');
                }
            }
            it.destroy();
        }
        cs.addSuper(cs);

        cs.setState(Scope:STATE_HIERARCHY_RESOLVED);
        this._traceStop(cs.getFullQualifiedName(), "resolved class hierarchy");
        
        // descent into referenced classes/structs
        node.getConsts().acceptAll(this.visitor());
        node.getVariables().acceptAll(this.visitor());
        node.getMethods().acceptAll(this.visitor());
        
        /*{
            AnyIterator sit = cs.getSupers();
            this.debug().print(cs.getFullQualifiedName()).printCString(": found supers");
            while (sit.hasNext()) { this.debug().printCString("   ").print(sit.next()); }
            sit.destroy();
        }*/
        _curScope = tmpScope;
        return true;
    }
    
    [int] visitStructDecl(StructDeclNode node) {
        Scope tmpScope := _curScope;
        StructScope ss := node.getStructScope();
        if (!ss || ss.getState() < Scope:STATE_TYPE_REFERENCES_RESOLVED) {
            this.error().print(node.getName()).printCString(": references must be resolved before resolving hierarchy!");
            _curScope = tmpScope;
            return false;
        }
        if (ss.getState() >= Scope:STATE_RESOLVING_HIERARCHY) {
            return true;
        }
        _curScope = ss.scope();
        
        //this._traceStart(ss.getFullQualifiedName(), "resolving struct hierarchy");
        ss.setState(Scope:STATE_HIERARCHY_RESOLVED);
        //this._traceStop(ss.getFullQualifiedName(), "resolved struct hierarchy");
        
        // descent into referenced classes/structs
        node.getConsts().acceptAll(this.visitor());
        node.getVariables().acceptAll(this.visitor());
        
        _curScope = tmpScope;
        return true;
    }
    
    // instructions
    
    // expressions
    
    // references
    [int] visitClassRef(ClassRefNode node) {
        ClassScope cs := this.rt().cast(ClassScope:CLASSNAME, node.getResolvedType());
        if (cs && cs.getState() < Scope:STATE_RESOLVING_HIERARCHY) {
            return cs.getClassDeclNode().accept(this.visitor());
        }
        StructScope ss := this.rt().cast(StructScope:CLASSNAME, node.getResolvedType());
        if (ss && ss.getState() < Scope:STATE_RESOLVING_HIERARCHY) {
            return ss.getStructDeclNode().accept(this.visitor());
        }
        return false;
    }
    
    // helper
}
