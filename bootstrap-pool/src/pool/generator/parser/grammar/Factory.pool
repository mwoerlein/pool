/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace pool::generator::parser::grammar;

use pool::generator::Symbol;

use sys::core::anycollection::AnyIterator;
use sys::stream::OStream;

class Factory extends sys::core::Object {

    [GrammarDefinition] definition() { return this.rt().createInstance(GrammarDefinition:CLASSNAME); }
    [Action] action() { return this.rt().createInstance(Action:CLASSNAME); }
    
    [Action] accept() { return this.action().setAccept(); }
    [Action] shift(State s) { return this.action().setShift(s); }
    [Action] reduce(Rule r) { return this.action().setReduce(r); }
    [Action] shiftReduce(Rule r) { return this.action().setShift(null).setReduce(r); }
    
    [Grammar] buildGrammar(GrammarDefinition def, OStream err, OStream dot) {
        GrammarBuilder gb = this.rt().createInstance(GrammarBuilder:CLASSNAME);
        Grammar g = gb.build(def, err);
        
//        OStream out = this.rt().out();
//        gb.debugNullable(out);
//        gb.debugFirst(out);
//        gb.debugFollow(out);
//        gb.debugGraph(dot);
        
        gb.destroy();
        return g;
    }
    
    /* 
     * use manually built parse grammar for regexes until pool::generator is finalized
     */
    [Grammar] buildRegexGrammar(OStream err, OStream dot) {
        // TODO: parse .gram file to definition
        GrammarDefinition def = this.definition();

        def.setCStringProperty("namespace", "pool::generator::regex");
        def.setCStringProperty("classname", "Parser");
        def.setCStringProperty("extends", "BaseParser");
        def.setCStringProperty("tokenizer", "Tokenizer");
        
        Symbol tCHAR        := def.getCSymbol("CHAR");
        Symbol tOBRACKET    := def.getCSymbol("OBRACKET");
        Symbol tCBRACKET    := def.getCSymbol("CBRACKET");
        Symbol tOSBRACKET   := def.getCSymbol("OSBRACKET");
        Symbol tCSBRACKET   := def.getCSymbol("CSBRACKET");
        Symbol tQMARK       := def.getCSymbol("QMARK");
        Symbol tSTAR        := def.getCSymbol("STAR");
        Symbol tPLUS        := def.getCSymbol("PLUS");
        Symbol tMINUS       := def.getCSymbol("MINUS");
        Symbol tCFLEX       := def.getCSymbol("CFLEX");
        Symbol tPIPE        := def.getCSymbol("PIPE");
        Symbol tDOT         := def.getCSymbol("DOT");

        Symbol ntEXPRESSION := def.getCSymbol("expression");    
        Symbol ntALTER      := def.getCSymbol("alter");    
        Symbol ntCONCAT     := def.getCSymbol("concat");
        Symbol ntELEM       := def.getCSymbol("elem");
        Symbol ntEXPR       := def.getCSymbol("expr");
        Symbol ntCLASS      := def.getCSymbol("class");
        
        def.newToken(tCHAR).setDefinition("/[^\\\\\\(\\)\\[\\]\\?\\*\\+\\-\\^\\|\\.\\/]|\\\\[nrt\\\\\\(\\)\\[\\]\\?\\*\\+\\-\\^\\|\\.\\/]/");
        def.newToken(tOBRACKET).setDefinition("/\\(/");
        def.newToken(tCBRACKET).setDefinition("/\\)/");
        def.newToken(tOSBRACKET).setDefinition("/\\[/");
        def.newToken(tCSBRACKET).setDefinition("/\\]/");
        def.newToken(tQMARK).setDefinition("/\\?/");
        def.newToken(tSTAR).setDefinition("/\\*/");
        def.newToken(tPLUS).setDefinition("/\\+/");
        def.newToken(tMINUS).setDefinition("/\\-/");
        def.newToken(tCFLEX).setDefinition("/\\^/");
        def.newToken(tPIPE).setDefinition("/\\|/");
        def.newToken(tDOT).setDefinition("/\\./");

        def.newRule(ntEXPRESSION).addRHS(ntALTER)
            .setCode("{ $$ = this.expression = $1; }");
        def.newRule(ntALTER).addRHS(ntCONCAT)
            .setCode("{ $$ = this.listAddNode(this.alter(), this.listToNode($1)); }");
        def.newRule(ntALTER).addRHS(ntALTER).addRHS(tPIPE).addRHS(ntCONCAT)
            .setCode("{ $$ = this.listAddNode($1, this.listToNode($3)); }");
        def.newRule(ntCONCAT).addRHS(ntELEM)
            .setCode("{ $$ = this.listAddNode(this.concat(), $1); }");
        def.newRule(ntCONCAT).addRHS(ntCONCAT).addRHS(ntELEM)
            .setCode("{ $$ = this.listAddNode($1, $2); }");
        def.newRule(ntELEM).addRHS(ntEXPR);
        def.newRule(ntEXPR).addRHS(ntEXPR).addRHS(tQMARK)
            .setCode("{ $$ = this.atMostOnce($1); }");
        def.newRule(ntEXPR).addRHS(ntEXPR).addRHS(tSTAR)
            .setCode("{ $$ = this.any($1); }");
        def.newRule(ntEXPR).addRHS(ntEXPR).addRHS(tPLUS)
            .setCode("{ $$ = this.atLeastOnce($1); }");
        def.newRule(ntEXPR).addRHS(tDOT)
            .setCode("{ $$ = this.all(); }");
        def.newRule(ntEXPR).addRHS(tCHAR)
            .setCode("{ $$ = this.single(this.toChar($1)); }");
        def.newRule(ntEXPR).addRHS(tOSBRACKET).addRHS(ntCLASS).addRHS(tCSBRACKET)
            .setCode("{ $$ = this.ccToNode($2); }");
        def.newRule(ntEXPR).addRHS(tOSBRACKET).addRHS(tCFLEX).addRHS(ntCLASS).addRHS(tCSBRACKET)
            .setCode("{ $$ = this.ccToExclusiveNode($3); }");
        def.newRule(ntEXPR).addRHS(tOBRACKET).addRHS(ntALTER).addRHS(tCBRACKET)
            .setCode("{ $$ = this.listToNode($2); }");
        def.newRule(ntCLASS).addRHS(tCHAR)
            .setCode("{ $$ = this.ccAddChar(this.cc(), this.toChar($1)); }");
        def.newRule(ntCLASS).addRHS(tCHAR).addRHS(tMINUS).addRHS(tCHAR)
            .setCode("{ $$ = this.ccAddRange(this.cc(), this.toChar($1), this.toChar($3)); }");
        def.newRule(ntCLASS).addRHS(ntCLASS).addRHS(tCHAR)
            .setCode("{ $$ = this.ccAddChar($1, this.toChar($2)); }");
        def.newRule(ntCLASS).addRHS(ntCLASS).addRHS(tCHAR).addRHS(tMINUS).addRHS(tCHAR)
            .setCode("{ $$ = this.ccAddRange($1, this.toChar($2), this.toChar($4)); }");

        return this.buildGrammar(def, err, dot);
    }
    
    /* 
     * use manually built parser grammar for pasm until pool::generator is finalized
     */
    [Grammar] buildPasmGrammar(OStream err, OStream dot) {
        // TODO: parse .gram file to definition
        GrammarDefinition def = this.definition();
        
        def.setCStringProperty("namespace", "pool::asm");
        def.setCStringProperty("classname", "Parser");
        def.setCStringProperty("extends", "BaseParser");
        def.setCStringProperty("tokenizer", "Tokenizer");
        
        Symbol tIDENTIFIER   := def.getCSymbol("IDENTIFIER");
        Symbol tREGISTER     := def.getCSymbol("REGISTER");
        Symbol tCHAR         := def.getCSymbol("CHAR");
        Symbol tSTRING       := def.getCSymbol("STRING");
        Symbol tNUMBER       := def.getCSymbol("NUMBER");
        Symbol tNEWLINE      := def.getCSymbol("NEWLINE");
        Symbol tSPACER       := def.getCSymbol("SPACER").setIgnore(true);
        Symbol tCOMMENT      := def.getCSymbol("COMMENT").setIgnore(true);
        Symbol tMLCOMMENT    := def.getCSymbol("MLCOMMENT").setIgnore(true);
        Symbol tOPERATOR     := def.getCSymbol("OPERATOR");
        Symbol tASSIGN       := def.getCSymbol("ASSIGN");
        Symbol tOBRACKET     := def.getCSymbol("OBRACKET");
        Symbol tCBRACKET     := def.getCSymbol("CBRACKET");
        Symbol tCOLON        := def.getCSymbol("COLON");
        Symbol tSEMICOLON    := def.getCSymbol("SEMICOLON");
        Symbol tCOMMA        := def.getCSymbol("COMMA");
        
        Symbol ntUNIT        := def.getCSymbol("compilation_unit");    
        Symbol ntLABEL       := def.getCSymbol("label");
        Symbol ntDEFINITION  := def.getCSymbol("definition");
        Symbol ntINSTRUCTION := def.getCSymbol("instruction");
        Symbol ntEOL         := def.getCSymbol("eol");
        Symbol ntOPERAND     := def.getCSymbol("operand");
        Symbol ntINDIRECT    := def.getCSymbol("indirect");
        Symbol ntFORMULA     := def.getCSymbol("formula");
        
        def.newToken(tIDENTIFIER).setDefinition("/[\\._a-zA-Z][_a-zA-Z0-9]*/");
        def.newToken(tREGISTER).setDefinition("/%[a-zA-Z][_a-zA-Z0-9]*/");
        def.newToken(tCHAR).setDefinition("/'([^\\\\\\n\\r']|\\\\[^\\n\\r\\t])*'/");
        def.newToken(tSTRING).setDefinition("/\"([^\\\\\\n\\r\"]|\\\\[^\\n\\r\\t])*\"/");
        def.newToken(tNUMBER).setDefinition("/\\-?(0[0-7]*|[1-9][0-9]*|0[bB][01]+|0[xX][0-9a-fA-F]+)/");
        def.newToken(tNEWLINE).setDefinition("/[\\n\\r]+/");
        def.newToken(tSPACER).setDefinition("/[ \\t]+/");
        def.newToken(tCOMMENT).setDefinition("/(\\/\\/|#)[^\\n\\r]*/");
        def.newToken(tMLCOMMENT).setDefinition("/\\/\\*([^\\*]*\\*+)([^\\/\\*][^\\*]*\\*+)*\\//");
        def.newToken(tOPERATOR).setDefinition("/(\\+|\\-|\\*|\\/|%|<<|>>|\\.)/");
        def.newToken(tASSIGN).setDefinition("/:=/");
        def.newToken(tCOLON).setDefinition("/:/");
        def.newToken(tOBRACKET).setDefinition("/\\(/");
        def.newToken(tCBRACKET).setDefinition("/\\)/");
        def.newToken(tSEMICOLON).setDefinition("/;/");
        def.newToken(tCOMMA).setDefinition("/,/");

        def.newRule(ntUNIT)
            .setCode("{ $$ = unit.getNodeList(); }");
        def.newRule(ntUNIT).addRHS(ntUNIT).addRHS(ntLABEL)
            .setCode("{ $$ = this.pushToList($1, $2); }");
        def.newRule(ntUNIT).addRHS(ntUNIT).addRHS(ntDEFINITION)
            .setCode("{ $$ = this.pushToList($1, $2); }");
        def.newRule(ntUNIT).addRHS(ntUNIT).addRHS(ntINSTRUCTION)
            .setCode("{ $$ = this.pushToList($1, $2); }");
        def.newRule(ntUNIT).addRHS(ntUNIT).addRHS(ntEOL);
        def.newRule(ntLABEL).addRHS(tIDENTIFIER).addRHS(tCOLON)
            .setCode("{ $$ = this.createLabel($1).node(); }");
        def.newRule(ntINSTRUCTION).addRHS(tIDENTIFIER).addRHS(ntEOL)
            .setCode("{ $$ = this.createInstruction($1).node(); }");
        def.newRule(ntINSTRUCTION).addRHS(tIDENTIFIER).addRHS(ntOPERAND).addRHS(ntEOL)
            .setCode("{ $$ = this.createInstruction($1).setOperand1($2).node(); }");
        def.newRule(ntINSTRUCTION).addRHS(tIDENTIFIER).addRHS(ntOPERAND).addRHS(tCOMMA).addRHS(ntOPERAND).addRHS(ntEOL)
            .setCode("{ $$ = this.createInstruction($1).setOperand1($2).setOperand2($4).node(); }");
        def.newRule(ntINSTRUCTION).addRHS(tIDENTIFIER).addRHS(ntOPERAND).addRHS(tCOMMA).addRHS(ntOPERAND).addRHS(tCOMMA).addRHS(ntOPERAND).addRHS(ntEOL)
            .setCode("{ $$ = this.createInstruction($1).setOperand1($2).setOperand2($4).setOperand3($6).node(); }");
        def.newRule(ntDEFINITION).addRHS(tIDENTIFIER).addRHS(tASSIGN).addRHS(ntOPERAND).addRHS(ntEOL)
            .setCode("{ $$ = this.createDefinition($1, $3).node(); }");
        def.newRule(ntEOL).addRHS(tSEMICOLON)
            .setCode("{ $$ = null; }");
        def.newRule(ntEOL).addRHS(tNEWLINE)
            .setCode("{ $$ = null; }");
        def.newRule(ntOPERAND).addRHS(tIDENTIFIER)
            .setCode("{ $$ = this.createIdentifier($1).operand(); }");
        def.newRule(ntOPERAND).addRHS(tREGISTER)
            .setCode("{ $$ = this.createRegister($1).operand(); }");
        def.newRule(ntOPERAND).addRHS(tNUMBER)
            .setCode("{ $$ = this.createNumber($1).operand(); }");
        def.newRule(ntOPERAND).addRHS(tCHAR)
            .setCode("{ $$ = this.createChar($1).operand(); }");
        def.newRule(ntOPERAND).addRHS(tSTRING)
            .setCode("{ $$ = this.createString($1).operand(); }");
        def.newRule(ntOPERAND).addRHS(ntINDIRECT);
        def.newRule(ntOPERAND).addRHS(ntFORMULA);
        def.newRule(ntINDIRECT).addRHS(tOBRACKET).addRHS(ntOPERAND).addRHS(tCBRACKET)
            .setCode("{ $$ = this.createIndirect().setBase($2).operand(); }");
        def.newRule(ntINDIRECT).addRHS(tOBRACKET).addRHS(ntOPERAND).addRHS(tCOMMA).addRHS(ntOPERAND).addRHS(tCBRACKET)
            .setCode("{ $$ = this.createIndirect().setBase($2).setIndex($4).operand(); }");
        def.newRule(ntINDIRECT).addRHS(tOBRACKET).addRHS(ntOPERAND).addRHS(tCOMMA).addRHS(ntOPERAND).addRHS(tCOMMA).addRHS(tNUMBER).addRHS(tCBRACKET)
            .setCode("{ $$ = this.createIndirect().setBase($2).setIndex($4).setScale(this.toInt($6)).operand(); }");
        def.newRule(ntINDIRECT).addRHS(tOBRACKET).addRHS(tCOMMA).addRHS(ntOPERAND).addRHS(tCBRACKET)
            .setCode("{ $$ = this.createIndirect().setIndex($3).operand(); }");
        def.newRule(ntINDIRECT).addRHS(tOBRACKET).addRHS(tCOMMA).addRHS(ntOPERAND).addRHS(tCOMMA).addRHS(tNUMBER).addRHS(tCBRACKET)
            .setCode("{ $$ = this.createIndirect().setIndex($3).setScale(this.toInt($5)).operand(); }");
        def.newRule(ntINDIRECT).addRHS(ntOPERAND).addRHS(tOBRACKET).addRHS(ntOPERAND).addRHS(tCBRACKET)
            .setCode("{ $$ = this.createIndirect().setDisplacement($1).setBase($3).operand(); }");
        def.newRule(ntINDIRECT).addRHS(ntOPERAND).addRHS(tOBRACKET).addRHS(ntOPERAND).addRHS(tCOMMA).addRHS(ntOPERAND).addRHS(tCBRACKET)
            .setCode("{ $$ = this.createIndirect().setDisplacement($1).setBase($3).setIndex($5).operand(); }");
        def.newRule(ntINDIRECT).addRHS(ntOPERAND).addRHS(tOBRACKET).addRHS(ntOPERAND).addRHS(tCOMMA).addRHS(ntOPERAND).addRHS(tCOMMA).addRHS(tNUMBER).addRHS(tCBRACKET)
            .setCode("{ $$ = this.createIndirect().setDisplacement($1).setBase($3).setIndex($5).setScale(this.toInt($7)).operand(); }");
        def.newRule(ntINDIRECT).addRHS(ntOPERAND).addRHS(tOBRACKET).addRHS(tCOMMA).addRHS(ntOPERAND).addRHS(tCBRACKET)
            .setCode("{ $$ = this.createIndirect().setDisplacement($1).setIndex($4).operand(); }");
        def.newRule(ntINDIRECT).addRHS(ntOPERAND).addRHS(tOBRACKET).addRHS(tCOMMA).addRHS(ntOPERAND).addRHS(tCOMMA).addRHS(tNUMBER).addRHS(tCBRACKET)
            .setCode("{ $$ = this.createIndirect().setDisplacement($1).setIndex($4).setScale(this.toInt($6)).operand(); }");
        def.newRule(ntFORMULA).addRHS(tOBRACKET).addRHS(ntOPERAND).addRHS(tOPERATOR).addRHS(ntOPERAND).addRHS(tCBRACKET)
            .setCode("{ $$ = this.createFormula($2, $3, $4).operand(); }");

        return this.buildGrammar(def, err, dot);
    }
    
}
