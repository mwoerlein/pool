/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace pool::languageserver;

use pool::languageserver::message::Message;
use pool::languageserver::message::MessageFactory;
use pool::languageserver::message::Response;
use pool::languageserver::message::UnknownMessage;
use pool::languageserver::message::lifecycle::ExitNotification;
use pool::languageserver::message::lifecycle::InitializedNotification;
use pool::languageserver::message::lifecycle::InitializeRequest;
use pool::languageserver::message::lifecycle::InitializeResponse;
use pool::languageserver::message::lifecycle::ShutdownRequest;
use pool::languageserver::message::textdocument::DidOpenNotification;
use pool::languageserver::message::textdocument::DidCloseNotification;
use pool::languageserver::message::textdocument::PublishDiagnosticsNotification;
use pool::languageserver::message::window::ShowMessageNotification;

use json::value::JsonValue;

use sys::core::String;
use sys::stream::OStream;

class Server extends sys::core::Task {

    MessageBus mb;
    MessageFactory mf;
    OStream debug;

    [] _initServer(MessageBus mb, MessageFactory mf, OStream debug) {
        this.mb = mb;
        this.mf = mf;
        this.debug = debug;
    }
    
    [int] run() {
        int state = -1;
        if (!this.awaitInitialization()) {
            debug.printCString("Initialization failed!").printNewline();
            return -1;
        }
        state = 0;
        while (state != 5) {
            while (mb.hasMessages()) {
                // TODO: determine and queue jobs from messages/notifications
                Message message := mb.getMessage();
                if (message) {
                    if (message.isClass(DidOpenNotification:CLASSNAME)) {
                        DidOpenNotification not = message.castTo(DidOpenNotification:CLASSNAME);
                        
                        debug.printCString("publish diagnostic").printNewline();
                        PublishDiagnosticsNotification diagnosticNotice = mf.createPublishDiagnosticsNotification()
                            .setUri(not.getUri())
                            .setVersion(not.getVersion());
                        mb.sendMessage(diagnosticNotice.message());
                        diagnosticNotice.destroy();
                    } else if (message.isClass(DidCloseNotification:CLASSNAME)) {
                        DidCloseNotification not = message.castTo(DidCloseNotification:CLASSNAME);
                        
                        debug.printCString("show message").printNewline();
                        ShowMessageNotification showMessage = mf.createShowMessageNotification();
                        showMessage.info().printCString("close URI: ").print(not.getUri());
                        mb.sendMessage(showMessage.message());
                        showMessage.destroy();
                    } else if (message.isClass(ShutdownRequest:CLASSNAME)) {
                        state = 3;
                        debug.printCString("acknowledge shutdown").printNewline();
                        mb.sendMessage(mf.createEmptyResponse(message.asRequest()).message());
                    } else if (message.isClass(ExitNotification:CLASSNAME)) {
                        state = 5;
                        debug.printCString("exiting ...");
                    } else if (message.isClass(UnknownMessage:CLASSNAME)) {
                        UnknownMessage mes = message.castTo(UnknownMessage:CLASSNAME);
                        debug.printCString("mirror raw message").printNewline();
                        mb.sendRawMessage(mes.getRaw());
                    } else {
                        debug.printCString("mirror message").printNewline();
                        mb.sendMessage(message);
                    }
                    message.destroy();
                }
            }
            
            if (mb.isClientGone()) {
                // TODO: queue shutdown job?
                debug.printCString("client gone => exit").printNewline();
                return 0;
            }
            // TODO: do queued job, if available, instead of busy waiting
            debug.printCString("Waiting for message...").printNewline();
            // TODO: blocking wait for message, if no job exists?
            this.rt().sleep(1,0);
        }
        
        debug.printCString("now").printNewline();
        return 0;
    }
    
    [int] awaitInitialization() {
        // await messages
        while (!mb.hasMessages()) {
            if (mb.isClientGone()) { return false; }
            debug.printCString("Waiting for initialization...").printNewline();
            // TODO: blocking wait for initialization?
            this.rt().sleep(1,0);
        }
        
        // TODO: detect and handle initialize correctly
        {
            Message message := mb.getMessage();
            
            if (message && message.isClass(InitializeRequest:CLASSNAME)) {
                debug.printCString("send initialize response").printNewline();
                // send initialize response
                InitializeRequest initializeRequest := message.castTo(InitializeRequest:CLASSNAME);
                initializeRequest.jsonToStream(debug).printNewline(); 
                InitializeResponse initializeResponse = mf.createInitializeResponse(initializeRequest);
                mb.sendMessage(initializeResponse.message());
                initializeResponse.destroy();
            } else {
                debug.printCString("send init error...").printNewline();
                // send error
                Response errorResponse = mf.createErrorResponse(message, -32600);
                errorResponse.errorMessage().printCString("expecting initialize as first message");
                mb.sendMessage(errorResponse.message());
                errorResponse.destroy();
            }
            
            if (message) { message.destroy(); }
        }
        
        // TODO: await initialized notification
        while (!mb.hasMessages()) {
            if (mb.isClientGone()) { return false; }
            debug.printCString("Waiting for finalizing initialization...").printNewline();
            // TODO: blocking wait for initialization?
            this.rt().sleep(1,0);
        }
        
        {
            Message message := mb.getMessage();
            
            if (message && message.isClass(InitializedNotification:CLASSNAME)) {
                debug.printCString("finalize initialization").printNewline();
                // finalize initialization
            } else {
                debug.printCString("send init error...").printNewline();
                // send error
                Response errorResponse = mf.createErrorResponse(message, -32600);
                errorResponse.errorMessage().printCString("expecting initialized as next message");
                mb.sendMessage(errorResponse.message());
                errorResponse.destroy();
            }
            
            if (message) { message.destroy(); }
        }

        return true;
    }
}
