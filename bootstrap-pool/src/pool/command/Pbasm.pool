/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace pool::command;

use pool::asm::InstructionList;
use pool::asm::Parser;
use pool::asm::CompilationUnit;
use pool::asm::i386::Compiler;
use sys::core::String;
use sys::core::anycollection::AnyIterator;
use sys::stream::IStream;
use sys::stream::OStream;
use sys::stream::SeekableIOStream;

class Pbasm extends linux::Command {

    int ERRNO_OK        := 0;
    int ERRNO_IO        := 1;
    int ERRNO_PARSE     := 2;
    int ERRNO_COMPILE   := 3;
    
    Parser parser;
    Compiler compiler;
    CompilationUnit unit;
    int status;

    [] __init() {
        this._initCommand();
        parser = this.rt().createInstance(Parser:CLASSNAME);
        compiler = this.rt().createInstance(Compiler:CLASSNAME);
        unit = this.rt().createInstance(CompilationUnit:CLASSNAME);
        status = ERRNO_OK;
    }
    
    [] __destruct() {
        unit.destroyAll();
        unit.destroy();
        compiler.destroy();
        parser.destroy();
        this._destructCommand();
    }
    
    [] configure() {
        this.setName("pbasm")
            .setVersion("0.3.0")
            .setUsage(<"
Pool Bootstrap Assembler.

    Usage:
      pasm [options] -o <file> <file>...

    Options:
      -h --help                 Show this screen.
      --version                 Show version.
      -o <file> --output <file> Place the output into <file>.
      -b --binary               Generate plain binary without module informations.
      -c --class                Generate class module informations.
      -t <org>                  Locates code in the output file at the absolute address given by org.
">);
        this.registerOptionAlias('h', "help")
            .registerOptionAlias('o', "output")
            .registerOptionAlias('b', "binary")
            .registerOptionAlias('c', "class")
        ;
    }

    [int] run() {
        OStream out = this.rt().out();
        if (this.hasOption("help")) {
            out.printCString(usage).printNewline();
            return 0;
        }
        if (this.hasOption("version")) {
            out.printCString(name).printChar(' ').printCString(version).printNewline();
            return 0;
        }
        if (!this.hasValueOption("output") || this.getArgumentsSize() < 1) {
            out.printCString(usage).printNewline();
            return -1;
        }
        
        int startAddress = 0;
        if (this.hasValueOption("t")) {
            startAddress = this.getValueOption("t").toInt();
        }
        
        OStream err = this.rt().err();
        SeekableIOStream outfile = this.openFile(this.getValueOption("output"), linux::File:MODE_WRITE);
        if (!outfile) { status = ERRNO_IO; }
        if (status == ERRNO_OK) {
            this.parse();
            if (unit.flushErrors(err)) { status = ERRNO_PARSE; }
        }
        if (status == ERRNO_OK) {
            this.rt().out().print(unit.getNodeList()); // DEBUG
            compiler.compile(unit);
            if (unit.flushErrors(err)) { status = ERRNO_COMPILE; }
        }
        if (status == ERRNO_OK) {
            compiler.validate(unit);
            if (unit.flushErrors(err)) { status = ERRNO_COMPILE; }
        }
        if (status == ERRNO_OK) {
            compiler.finalize(unit, startAddress);
            if (unit.flushErrors(err)) { status = ERRNO_COMPILE; }
        }
        if (status == ERRNO_OK) { this.writeOutput(outfile.ostream()); }
        
        outfile.destroy();
        return status;
    }
    
    [] parse() {
        AnyIterator argIt = this.getArguments();
        while (argIt.hasNext()) {
            String name = argIt.next();
            if (name.compareCString("-") == 0) {
                parser.parse(this.openStdIn(), name, unit);
            } else {
                SeekableIOStream f = this.openFile(name, linux::File:MODE_READ);
                if (!f) { status = ERRNO_IO; }
                if (status == ERRNO_OK) { parser.parse(f.istream(), name, unit); }
            }
        }
        argIt.destroy();
    }
    
    [] writeOutput(OStream out) {
        // generate module infos
        if (!this.hasOption("binary")) {
            out.printCString("/*[meta]").printNewline();
            out.printCString("mimetype = application/x-bin-x86").printNewline();
            
            out.printCString("[pool]").printNewline();
            out.printCString("version = ").printCString(version).printNewline();
            if (this.hasOption("class")) {
                out.printCString("class = true").printNewline();
            }
            out.printCString("* /").printNewline();
        }
        unit.rawToStream(out);
    }
    
    // methods
    __entry__ [int] entry(int argc, int argv) {
        Pbasm pbasm = linux::Runtime:buildRuntime().createInstance(Pbasm:CLASSNAME);
        return pbasm.execute(argc, argv);
    }
}
