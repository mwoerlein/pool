/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace pool::command;

use pool::compiler::ast::Node;
use pool::compiler::ast::visitor::PrettyPrinter;
use pool::compiler::parser::Parser;
use pool::storage::ClassPathStorage;
use pool::storage::PoolStorage;

use sys::core::String;
use sys::core::anycollection::AnyIterator;
use sys::store::StorageElement;
use sys::stream::IStream;
use sys::stream::OStream;
use sys::stream::SeekableIOStream;

class PoolCompiler extends linux::Command {

    Parser parser;

    [] __init() {
        this._initCommand();
        parser = this.createOwn(Parser:CLASSNAME);
    }
    
    [] configure() {
        this.setName("poolc")
            .setVersion("0.3.0")
            .setUsage(<"
Pool Bootstrap Compiler.

    Usage:
      poolbc [options] -o <dir> [-p <dir>] -c <dir> [-c <dir>]... <fqn>...

    Options:
      -h --help                     Show this screen.
      --version                     Show version.
      -o <dir> --output <dir>       Place the (pasm) outputs into <dir>.
      -c <dir> --classpath <dir>    Search for classes in all of these directories.
      -p <dir> --prettyprint <dir>  Dump classes into <dir>.
      -r --recursive                Generate output for all required classes.
">);
        this.registerOptionAlias('h', "help")
            .registerOptionAlias('o', "output")
            .registerOptionAlias('p', "prettyprint")
            .registerOptionAlias('c', "classpath").registerOptionList("classpath")
            .registerOptionAlias('r', "recursive")
        ;
    }

    [int] run() {
        OStream out = this.rt().out();
        if (this.hasOption("help")) {
            out.printCString(usage).printNewline();
            return 0;
        }
        if (this.hasOption("version")) {
            out.printCString(name).printChar(' ').printCString(version).printNewline();
            return 0;
        }
        if (!this.hasOption("output") || this.getArgumentsSize() < 1 || this.getListOptionSize("classpath") < 1) {
            out.printCString(usage).printNewline();
            return -1;
        }
        
        // TODO: handle log-level/logging
        
        ClassPathStorage classPath = this.rt().createInstance(ClassPathStorage:CLASSNAME);
        {
            AnyIterator it = this.getListOption("classpath");
            while (it.hasNext()) {
                classPath.add(this.openDirectory(it.next()).poolStorage());
            }
            it.destroy();
        }
        
        PoolStorage outPS = this.openDirectory(this.getValueOption("output")).poolStorage();
        
        PrettyPrinter pp = null;
        if (this.hasOption("prettyprint")) {
            pp = this.rt().createInstance(PrettyPrinter:CLASSNAME);
            pp.setStorage(this.openDirectory(this.getValueOption("prettyprint")).poolStorage());
        }
        
        OStream err = this.rt().err();
        Node unit = null;
        {
            AnyIterator fqnIt = this.getArguments();
            if (this.hasOption("recursive")) {
                // TODO: load all fqns and replace fqnIt
            }
            while (fqnIt.hasNext()) {
                String fqn = fqnIt.next();
                out.printCString("compile ").print(fqn).printNewline();
                StorageElement elem = classPath.getSourceClass(fqn);
                Node unit = parser.parse(elem, fqn);
                if (pp) { pp.visit(unit); }
            }
            fqnIt.destroy();
        }
        if (pp) { pp.destroy(); }
        outPS.destroy();
        classPath.destroy();
    }
    
    // methods
    __entry__ [int] entry(int argc, int argv) {
        PoolCompiler poolc = linux::Runtime:buildRuntime().createInstance(PoolCompiler:CLASSNAME);
        return poolc.execute(argc, argv);
    }
}
