/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace pool::asm;

use pool::asm::ast::InstructionNode;
use pool::asm::ast::NodeList;
use pool::asm::ast::OperandNode;
use pool::asm::ast::operand::FormulaNode;
use pool::asm::ast::operand::IdentifierNode;
use pool::asm::ast::operand::IndirectNode;
use pool::asm::ast::operand::NumberNode;
use pool::asm::ast::operand::RegisterNode;
use pool::asm::ast::operand::StringNode;

use pool::asm::token::Token;
use pool::asm::token::Tokenizer;

use sys::core::Object;
use sys::core::String;
use sys::stream::IStream;
use sys::stream::OStream;

class Parser extends pool::asm::token::Grammar {
    
    [FormulaNode] createFormula(OperandNode o1, cstring op, OperandNode o2) {
        FormulaNode formula = this.rt().createInstance(FormulaNode:CLASSNAME);
        formula.initCFormula(o1, op, o2);
        return formula;
    }
    
    [IdentifierNode] createIdentifier(cstring i) {
        IdentifierNode id = this.rt().createInstance(IdentifierNode:CLASSNAME);
        id.setCIdentifier(i);
        return id;
    }

    [NumberNode] createNumber(int o) {
        NumberNode n = this.rt().createInstance(NumberNode:CLASSNAME);
        n.setOperand(o);
        return n;
    }
    
    [RegisterNode] createRegister(cstring r) {
        RegisterNode reg = this.rt().createInstance(RegisterNode:CLASSNAME);
        reg.setCRegister(r);
        return reg;
    }
    
    [StringNode] createString(cstring o) {
        StringNode s = this.rt().createInstance(StringNode:CLASSNAME);
        s.setCOperand(o);
        return s;
    }

    [IndirectNode] buildIndirect() {
        return this.rt().createInstance(IndirectNode:CLASSNAME);
    }
/*
// ignore SPACER & COMMENT

translation_unit:
    // empty
|   translation_unit label
|   translation_unit definition
|   translation_unit instruction
|   translation_unit eol
;
    
label:
    IDENTIFIER ':'    
;

instruction:
    IDENTIFIER eol
|   IDENTIFIER operand eol
|   IDENTIFIER operand ',' operand eol
|   IDENTIFIER operand ',' operand ',' operand eol
;

definition:
    IDENTIFIER ASSIGN operand eol
;

eol:
    ';'
|   NEWLINE
;

operand:
    IDENTIFIER
|   REGISTER
|   NUMBER
|   CHAR
|   STRING
|   indirect
|   formula
;

indirect:
    '(' operand ')'
|   '(' operand ',' operand ')'
|   '(' operand ',' operand ',' NUMBER ')'
|   '(' ',' operand ')'
|   '(' ',' operand ',' NUMBER ')'
|   operand '(' operand ')'
|   operand '(' operand ',' operand ')'
|   operand '(' operand ',' operand ',' NUMBER ')'
|   operand '(' ',' operand ')'
|   operand '(' ',' operand ',' NUMBER ')'
;

formula:
    '(' operand OPERATOR operand ')'
;
*/
    // symbols
    int TRANSLATION_UNIT    := 0;    
    int LABEL               := 1;
    int DEFINITION          := 2;
    int INSTRUCTION         := 3;
    int EOL                 := 4;
    int OPERAND             := 5;
    int INDIRECT            := 6;
    int FORMULA             := 7;
    
    [] initRules() {
        // translation_unit:
        /*  0 */ this.addRule(Parser:TRANSLATION_UNIT);
        /*  1 */ this.addRule(Parser:TRANSLATION_UNIT).symbol(Parser:TRANSLATION_UNIT).symbol(Parser:LABEL);
        /*  2 */ this.addRule(Parser:TRANSLATION_UNIT).symbol(Parser:TRANSLATION_UNIT).symbol(Parser:DEFINITION);
        /*  3 */ this.addRule(Parser:TRANSLATION_UNIT).symbol(Parser:TRANSLATION_UNIT).symbol(Parser:INSTRUCTION);
        /*  4 */ this.addRule(Parser:TRANSLATION_UNIT).symbol(Parser:TRANSLATION_UNIT).symbol(Parser:EOL);
        
        // label:
        /*  5 */ this.addRule(Parser:LABEL).terminal(Token:IDENTIFIER).terminal(Token:COLON);
        
        // instruction:
        /*  6 */ this.addRule(Parser:INSTRUCTION).terminal(Token:IDENTIFIER).symbol(Parser:EOL);
        /*  7 */ this.addRule(Parser:INSTRUCTION).terminal(Token:IDENTIFIER).symbol(Parser:OPERAND).symbol(Parser:EOL);
        /*  8 */ this.addRule(Parser:INSTRUCTION).terminal(Token:IDENTIFIER).symbol(Parser:OPERAND)
                    .terminal(Token:COMMA).symbol(Parser:OPERAND).symbol(Parser:EOL);
        /*  9 */ this.addRule(Parser:INSTRUCTION).terminal(Token:IDENTIFIER).symbol(Parser:OPERAND)
                    .terminal(Token:COMMA).symbol(Parser:OPERAND)
                    .terminal(Token:COMMA).symbol(Parser:OPERAND).symbol(Parser:EOL);
            
        // definition:
        /* 10 */ this.addRule(Parser:DEFINITION).terminal(Token:IDENTIFIER)
                    .terminal(Token:ASSIGN).symbol(Parser:OPERAND).symbol(Parser:EOL);
        
        // eol:
        /* 11 */ this.addRule(Parser:EOL).terminal(Token:SEMICOLON);
        /* 12 */ this.addRule(Parser:EOL).terminal(Token:NEWLINE);
        
        // operand:
        /* 13 */ this.addRule(Parser:OPERAND).terminal(Token:IDENTIFIER);
        /* 14 */ this.addRule(Parser:OPERAND).terminal(Token:REGISTER);
        /* 15 */ this.addRule(Parser:OPERAND).terminal(Token:NUMBER);
        /* 16 */ this.addRule(Parser:OPERAND).terminal(Token:CHAR);
        /* 17 */ this.addRule(Parser:OPERAND).terminal(Token:STRING);
        /* 18 */ this.addRule(Parser:OPERAND).symbol(Parser:INDIRECT);
        /* 19 */ this.addRule(Parser:OPERAND).symbol(Parser:FORMULA);
        
        // indirect:
        /* 20 */ this.addRule(Parser:INDIRECT).terminal(Token:OBRACKET).symbol(Parser:OPERAND)
                    .terminal(Token:CBRACKET);
        /* 21 */ this.addRule(Parser:INDIRECT).terminal(Token:OBRACKET).symbol(Parser:OPERAND)
                    .terminal(Token:COMMA).symbol(Parser:OPERAND)
                    .terminal(Token:CBRACKET);
        /* 22 */ this.addRule(Parser:INDIRECT).terminal(Token:OBRACKET).symbol(Parser:OPERAND)
                    .terminal(Token:COMMA).symbol(Parser:OPERAND)
                    .terminal(Token:COMMA).terminal(Token:NUMBER)
                    .terminal(Token:CBRACKET);
        /* 23 */ this.addRule(Parser:INDIRECT).terminal(Token:OBRACKET)
                    .terminal(Token:COMMA).symbol(Parser:OPERAND)
                    .terminal(Token:CBRACKET);
        /* 24 */ this.addRule(Parser:INDIRECT).terminal(Token:OBRACKET)
                    .terminal(Token:COMMA).symbol(Parser:OPERAND)
                    .terminal(Token:COMMA).terminal(Token:NUMBER)
                    .terminal(Token:CBRACKET);
            
        /* 25 */ this.addRule(Parser:INDIRECT).symbol(Parser:OPERAND)
                    .terminal(Token:OBRACKET).symbol(Parser:OPERAND)
                    .terminal(Token:CBRACKET);
        /* 26 */ this.addRule(Parser:INDIRECT).symbol(Parser:OPERAND)
                    .terminal(Token:OBRACKET).symbol(Parser:OPERAND)
                    .terminal(Token:COMMA).symbol(Parser:OPERAND)
                    .terminal(Token:CBRACKET);
        /* 27 */ this.addRule(Parser:INDIRECT).symbol(Parser:OPERAND)
                    .terminal(Token:OBRACKET).symbol(Parser:OPERAND)
                    .terminal(Token:COMMA).symbol(Parser:OPERAND)
                    .terminal(Token:COMMA).terminal(Token:NUMBER)
                    .terminal(Token:CBRACKET);
        /* 28 */ this.addRule(Parser:INDIRECT).symbol(Parser:OPERAND)
                    .terminal(Token:OBRACKET)
                    .terminal(Token:COMMA).symbol(Parser:OPERAND)
                    .terminal(Token:CBRACKET);
        /* 29 */ this.addRule(Parser:INDIRECT).symbol(Parser:OPERAND)
                    .terminal(Token:OBRACKET)
                    .terminal(Token:COMMA).symbol(Parser:OPERAND)
                    .terminal(Token:COMMA).terminal(Token:NUMBER)
                    .terminal(Token:CBRACKET);
            
        // formula:
        /* 30 */ this.addRule(Parser:FORMULA).terminal(Token:OBRACKET)
                    .symbol(Parser:OPERAND).terminal(Token:OPERATOR).symbol(Parser:OPERAND)
                    .terminal(Token:CBRACKET);
            
    }
    
    [__any__] executeRule(int rule, int /*AnyStack*/ s) {
        // translation_unit:
        if (rule ==  0) { return null; /* return Address:convert(unit.getNodeList()); */ }
        else if (rule ==  1) { return null; /* NodeList list = s.at(0); LabelNode label = s.at(1); list.addLabel(label); return s.at(0); */ }
        else if (rule ==  2) { return null; /* NodeList list = s.at(0); DefinitionNode def = s.at(1); list.addDefinition(def); return s.at(0); */ }
        else if (rule ==  3) { return null; /* NodeList list = s.at(0); InstructionNode inst = s.at(1); list.addInstruction(inst); return return s.at(0); */ }
        else if (rule ==  4) { return null; /* return s.at(0); */ }
        
        // label:
        else if (rule ==  5) { return null; /* Token t = s.at(0); return Address:convert(this.createLabel(t)); */ }
        
        // instruction:
        else if (rule ==  6) { return null; /* Token t = s.at(0); return Address:convert(this.createInst0(t)); */ }
        else if (rule ==  7) { return null; /* Token t = s.at(0); OperandNode o1 = s.at(2); return Address:convert(this.createInst1(t, o1)); */ }
        else if (rule ==  8) { return null; /* Token t = s.at(0); OperandNode o1 = s.at(2); OperandNode o1 = s.at(4); return Address:convert(this.createInst2(t, o1, o2)); */ }
        else if (rule ==  9) { return null; /* Token t = s.at(0); OperandNode o1 = s.at(2); OperandNode o1 = s.at(4); OperandNode o1 = s.at(6); return Address:convert(this.createInst3(t, o1, o2, o3)); */ }
        
        // definition:
        else if (rule ==  10) { return null; /* Token t = s.at(0); OperandNode o = s.at(3); return Address:convert(this.createDefinition(t, o)); */ }
        
        // eol:
        else if (rule ==  11) { return null; /* return s.at(0); */ }
        else if (rule ==  12) { return null; /* return s.at(0); */ }
        
        // operand:
        else if (rule ==  13) { return null; /* Token t = s.at(0); return Address:convert(this.createIdentifier(t).operand()); */ }
        else if (rule ==  14) { return null; /* Token t = s.at(0); return Address:convert(this.createRegister(t).operand()); */ }
        else if (rule ==  15) { return null; /* Token t = s.at(0); return Address:convert(this.createNumber(t).operand()); */ }
        else if (rule ==  16) { return null; /* Token t = s.at(0); return Address:convert(this.createChar(t).operand()); */ }
        else if (rule ==  17) { return null; /* Token t = s.at(0); return Address:convert(this.createString(t).operand()); */ }
        else if (rule ==  18) { return null; /* IndirectNode i = s.at(0); return Address:convert(i.operand()); */ }
        else if (rule ==  19) { return null; /* FormulaNode f = s.at(0); return Address:convert(f.operand()); */ }
        
        // indirect:
        else if (rule ==  20) { return null; /* OperandNode d = null; OperandNode b = s.at(1); OperandNode i = null; Token s = null; return Address:convert(this.createIndirect(d, b, i, s)); */ }
        else if (rule ==  21) { return null; /* OperandNode d = null; OperandNode b = s.at(1); OperandNode i = s.at(3); Token s = null; return Address:convert(this.createIndirect(d, b, i, s)); */ }
        else if (rule ==  22) { return null; /* OperandNode d = null; OperandNode b = s.at(1); OperandNode i = s.at(3); Token s = s.at(5); return Address:convert(this.createIndirect(d, b, i, s)); */ }
        else if (rule ==  23) { return null; /* OperandNode d = null; OperandNode b = null; OperandNode i = s.at(2); Token s = null; return Address:convert(this.createIndirect(d, b, i, s)); */ }
        else if (rule ==  24) { return null; /* OperandNode d = null; OperandNode b = null; OperandNode i = s.at(2); Token s = s.at(4); return Address:convert(this.createIndirect(d, b, i, s)); */ }
        else if (rule ==  25) { return null; /* OperandNode d = s.at(0); OperandNode b = s.at(2); OperandNode i = null; Token s = null; return Address:convert(this.createIndirect(d, b, i, s)); */ }
        else if (rule ==  26) { return null; /* OperandNode d = s.at(0); OperandNode b = s.at(2); OperandNode i = s.at(4); Token s = null; return Address:convert(this.createIndirect(d, b, i, s)); */ }
        else if (rule ==  27) { return null; /* OperandNode d = s.at(0); OperandNode b = s.at(2); OperandNode i = s.at(4); Token s = s.at(6); return Address:convert(this.createIndirect(d, b, i, s)); */ }
        else if (rule ==  28) { return null; /* OperandNode d = s.at(0); OperandNode b = null; OperandNode i = s.at(3); Token s = null; return Address:convert(this.createIndirect(d, b, i, s)); */ }
        else if (rule ==  29) { return null; /* OperandNode d = s.at(0); OperandNode b = null; OperandNode i = s.at(3); Token s = s.at(5); return Address:convert(this.createIndirect(d, b, i, s)); */ }
        
        // formula:
        else if (rule ==  30) { return null; /* OperandNode o1 = s.at(1); Token op = s.at(2); OperandNode o2 = s.at(3); return Address:convert(this.createFormula(o1, op, o2)); */ }
        
        // TODO unknown rule;
        return null;
    }

    [] parse(IStream input, String name, CompilationUnit unit) {
        NodeList list = unit.getNodeList();
        
        //*/
        Tokenizer in = this.rt().createInstance(Tokenizer:CLASSNAME);
        in.init(input, name);
        OStream out = this.rt().out();
        out.print(name).printNewline();
        while (in.hasNext()) {
            Token t = in.next();
            t.debugToStream(out).printNewline();
            t.destroy();
        }
        in.destroy();
        out.print(this);
        /*/
        list.addCMultilineComment(<"
a comment
with multiple lines
">);
        list.addCInstruction0(".code32");
        list.addCLabel("test1");
        list.addCDefinition("base", this.createNumber(8).operand()).setCComment(" a constant");
        list.addCDefinition("form", 
            this.createFormula(
                this.createNumber(0x123).operand(),
                "+",
                this.createFormula(
                    this.createNumber(0x234).operand(),
                    "%",
                    this.createIdentifier("base").operand()
                ).operand()
            ).operand()
        ).setCComment(" a formula");
        list.addCDefinition("str", this.createString("foo").operand()).setCComment(" string constant");
        list.addCDefinition("reg", this.createRegister("cx").operand());
        list.addCInstruction0("sTi");
        list.addCInstruction0("pusha");
        list.addCInstruction0("pushaw");
        list.addCInstruction0("pushad");
        list.addCInstruction1(".byte", this.createNumber(0x11).operand());
        list.addCInstruction1(".bytet", this.createNumber(0x11223344).operand());
        list.addCInstruction1(".word", this.createNumber(0x1122).operand());
        list.addCInstruction1(".wordt", this.createNumber(0x11223344).operand());
        list.addCInstruction1(".long", this.createNumber(0x11223344).operand());
        
        list.addCInstruction1(".long", this.createIdentifier("test2").operand());
        list.addCInstruction1(".long", this.createIdentifier("base").operand());
        list.addCInstruction1(".long", this.createIdentifier("form").operand());
        
        list.addEmptyLine();
        list.addCInstruction0(".code16");
        list.addCComment(" single comment");
        list.addCLabel("test2").setCComment(" comment");
        list.addCInstruction0("pusha");
        list.addCInstruction0("pushaw");
        list.addCInstruction0("pushad");
        
        list.addCInstruction2(
            "mOVl",
            this.createIdentifier("reg").operand(),
            this.createRegister("cR0").operand()
        );
        list.addCInstruction2(
            "mOVl",
            this.createFormula(
                this.createNumber(0x123).operand(),
                "+",
                this.createFormula(
                    this.createNumber(0x234).operand(),
                    "%",
                    this.createIdentifier("base").operand()
                ).operand()
            ).operand(),
            this.buildIndirect()
                .setBase(this.createRegister("eax").operand())
                .setIndex(this.createRegister("ebx").operand())
                .setDisplacement(this.createNumber(16).operand())
                .operand()
        ).setData(32).setCPrefix("lock");
        list.addCInstruction0("Hlt").setCComment(" finish example");
        //*/
    }

}
