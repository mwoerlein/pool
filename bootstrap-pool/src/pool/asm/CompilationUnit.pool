/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace pool::asm;

use pool::asm::ast::CodeNode;
use pool::asm::ast::NodeList;
use pool::asm::ast::Node;

use pool::asm::ast::operand::FormulaNode;
use pool::asm::ast::operand::IdentifierNode;
use pool::asm::ast::operand::IndirectNode;
use pool::asm::ast::operand::RegisterNode;

use pool::asm::value::IdentifierValue;
use pool::asm::value::NumberValue;
use pool::asm::value::NumericOperation;
use pool::asm::value::PositionValue;
use pool::asm::value::StringValue;
use pool::asm::value::TextOperation;

use sys::core::anycollection::AnyIterator;
use sys::core::anycollection::AnyList;
use sys::core::anycollection::AnyMap;
use sys::core::String;
use sys::core::utils::Owner;
use sys::stream::OStream;

class CompilationUnit extends AnyList, Owner { // LinkedList<CompilationBlock>
    
    NodeList nodeList;
    AnyList errors; // LinkedList<String>
    AnyMap definitions; // HashMap<String, Definition>

    [] __init() {
        sys::runtime::Runtime rt = this.rt();
        nodeList = rt.createInstance(NodeList:CLASSNAME);
        errors = rt.createInstance(AnyList:CLASSNAME);
        definitions = rt.createInstance(AnyMap:CLASSNAME);
        definitions.init(13);
        this._initOwner();
    }

    [] __destruct() {
        errors.destroy();
        definitions.destroy();
        nodeList.destroy();
        this.clear();
        this._destructOwner();
    }
    
    [NodeList] getNodeList() {
        return nodeList;
    }
    
    [] addDefinition(Node node, String id, Value v) {
        Definition def = this.createOwn(Definition:CLASSNAME);
        def.init(node, this.createOwnStringFromString(id), v);
        definitions.set(def.getId(), def);
    }
    [int] hasDefinition(String id) { return definitions.has(id); }
    [int] hasPosition(String id) {
        Definition def = definitions.get(id);
        return def && this.rt().cast(PositionValue:CLASSNAME, def.getValue());
    }
    [Value] getValue(String id) {
        Definition def = definitions.get(id);
        if (def) { return def.getValue(); }
        return null;
    }
    
    [AnyIterator] definitions() { return definitions.values(); }
    
    [CompilationBlock] addBlock(CodeNode code) {
        CompilationBlock block = this.last();
        if (!block || !block.isEmpty()) {
            block = this.createOwn(CompilationBlock:CLASSNAME);
            this.add(block); 
        }
        block.init(code, this);
        return block;
    }
    
    [AnyIterator] blocks() { return this.iterator(); }
    
    [Value] _buildNumberValue(int n) {
        NumberValue num = this.createOwn(NumberValue:CLASSNAME);
        num.init(n);
        return num.value();
    }
    
    [Value] _buildIdentifierValue(IdentifierNode n) {
        IdentifierValue id = this.createOwn(IdentifierValue:CLASSNAME);
        id.init(n);
        return id.value();
    }
    
    [Value] _buildStringValue(String n) {
        StringValue str = this.createOwn(StringValue:CLASSNAME);
        str.init(n);
        return str.value();
    }
    
    [Value] _buildTextOperation(FormulaNode n, Value o1, int op, Value o2) {
        TextOperation o = this.createOwn(TextOperation:CLASSNAME);
        o.init(n, o1, op, o2);
        return o.value();
    }
    
    [Value] _buildNumericOperation(FormulaNode n, Value o1, int op, Value o2) {
        NumericOperation o = this.createOwn(NumericOperation:CLASSNAME);
        o.init(n, o1, op, o2);
        return o.value();
    }
    
    [Value] _buildPositionValue(Instruction i) {
        PositionValue value = this.createOwn(PositionValue:CLASSNAME);
        value.init(i);
        return value.value();
    }

    [int] hasErrors() {
        return errors.size() > 0;
    }
    
    [String] newError() {
        String err = this.createOwn(String:CLASSNAME);
        errors.add(err);
        return err;
    }
    
    [int] flushErrors(OStream stream) {
        if (errors.size() == 0) {
            return false;
        }
        
        {
            AnyIterator it = errors.iterator();
            while (it.hasNext()) { stream.print(it.next()).printNewline(); }
            it.destroy();
        }
        errors.clear();
        return true;
    }
    
    [OStream] rawToStream(OStream stream) {
        {
            AnyIterator bit = this.blocks();
            while (bit.hasNext()) {
                CompilationBlock block = bit.next();
                {
                    AnyIterator iit = block.instructions();
                    while (iit.hasNext()) {
                        Instruction inst = iit.next();
                        inst.rawToStream(stream);
                    }
                    iit.destroy();
                }
            }
            bit.destroy();
        }
        return stream;
    }
}
