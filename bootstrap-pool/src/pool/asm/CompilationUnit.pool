/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace pool::asm;

use pool::asm::ast::CodeNode;
use pool::asm::ast::NodeList;
use pool::asm::definition::PositionDefinition;

use sys::core::anycollection::AnyIterator;
use sys::core::anycollection::AnyList;
use sys::core::anycollection::AnyMap;
use sys::core::String;
use sys::core::utils::Owner;
use sys::stream::OStream;

class CompilationUnit extends AnyList, Owner { // LinkedList<CompilationBlock>
    
    NodeList nodeList;
    AnyList errors; // LinkedList<String>
    AnyMap definitions; // HashMap<String, Definition>

    [] __init() {
        sys::runtime::Runtime rt = this.rt();
        nodeList = rt.createInstance(NodeList:CLASSNAME);
        errors = rt.createInstance(AnyList:CLASSNAME);
        definitions = rt.createInstance(AnyMap:CLASSNAME);
        definitions.init(13);
        this._initOwner();
    }

    [] __destruct() {
        errors.destroy();
        definitions.destroy();
        nodeList.destroy();
        this.clear();
        this._destructOwner();
    }
    
    [NodeList] getNodeList() {
        return nodeList;
    }
    
    [] addDefinition(Definition def) {
        Definition prev = definitions.set(this.createOwnStringFromString(def.getId()), def);
        if (prev) { prev.destroy(); }
    }
    [int] hasDefinition(String id) { return definitions.has(id); }
    [int] hasPosition(String id) {
        return definitions.has(id) && this.rt().cast(PositionDefinition:CLASSNAME, definitions.get(id));
    }
    
    [AnyIterator] definitions() { return definitions.values(); }
    
    [CompilationBlock] addBlock(CodeNode code) {
        CompilationBlock block = this.last();
        if (!block || !block.isEmpty()) {
            block = this.createOwn(CompilationBlock:CLASSNAME);
            this.add(block); 
        }
        block.init(code, this);
        return block;
    }
    
    [AnyIterator] blocks() { return this.iterator(); }
    
    [int] hasErrors() {
        return errors.size() > 0;
    }
    
    [String] newError() {
        String err = this.createOwn(String:CLASSNAME);
        errors.add(err);
        return err;
    }
    
    [int] flushErrors(OStream stream) {
        if (errors.size() == 0) {
            return false;
        }
        
        {
            AnyIterator it = errors.iterator();
            while (it.hasNext()) { stream.print(it.next()).printNewline(); }
            it.destroy();
        }
        errors.clear();
        return true;
    }
    
    [OStream] rawToStream(OStream stream) {
        {
            AnyIterator bit = this.blocks();
            while (bit.hasNext()) {
                CompilationBlock block = bit.next();
                {
                    AnyIterator iit = block.instructions();
                    while (iit.hasNext()) {
                        Instruction inst = iit.next();
                        inst.rawToStream(stream);
                    }
                    iit.destroy();
                }
            }
            bit.destroy();
        }
        return stream;
    }
}
