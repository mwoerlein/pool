/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace vector::graphics::shape;

use sys::core::Float;
use vector::graphics::path::Path;

class Ring extends AbstractShape {
    
    Float x;
    Float y;
    Float outer;
    Float inner;
    
    [Ring] _initCCircle(cstring x, cstring y, cstring radius) {
        this.x = this.createOwnFloatFromCString(x);
        this.y = this.createOwnFloatFromCString(y);
        this.outer = this.createOwnFloatFromCString(radius);
        this.inner = null;
        // assert outer > 0.0
        return this;
    }
    
    [Ring] _initCRing(cstring x, cstring y, cstring outer, cstring inner) {
        this.x = this.createOwnFloatFromCString(x);
        this.y = this.createOwnFloatFromCString(y);
        this.outer = this.createOwnFloatFromCString(outer);
        this.inner = this.createOwnFloatFromCString(inner);
        // assert outer > inner >= 0.0
        return this;
    }
    
    [Float] getX() { return x; }
    [Float] getY() { return y; }
    [Float] getRadius() { return outer; }
    [Float] getOuterRadius() { return outer; }
    [Float] getInnerRadius() { return inner; }
    
    [int] hasInnerRadius() { return inner && (inner.compareFlt(Float:ZERO_POS) > 0); }
    
    // 4. * (sqrt(2.) - 1.) / 3.
    global int S_FACTOR := 0x3f0d6288;
    
    [Path] getPath() {
        int x := this.x.getFlt();
        int y := this.y.getFlt();
        
        Path p = this.createOwn(Path:CLASSNAME);
        
        //outer ring
        {
            int ro := outer.getFlt();
            int so := Float:mulFlts(ro, Ring:S_FACTOR);
            p.moveFltTo(x, Float:addFlts(y, ro))
                .curveFltTo(
                    Float:addFlts(x, so), Float:addFlts(y, ro),
                    Float:addFlts(x, ro), Float:addFlts(y, so),
                    Float:addFlts(x, ro), y
                )
                .curveFltTo(
                    Float:addFlts(x, ro), Float:subFlts(y, so),
                    Float:addFlts(x, so), Float:subFlts(y, ro),
                    x, Float:subFlts(y, ro)
                )
                .curveFltTo(
                    Float:subFlts(x, so), Float:subFlts(y, ro),
                    Float:subFlts(x, ro), Float:subFlts(y, so),
                    Float:subFlts(x, ro), y
                )
                .curveFltTo(
                    Float:subFlts(x, ro), Float:addFlts(y, so),
                    Float:subFlts(x, so), Float:addFlts(y, ro),
                    x, Float:addFlts(y, ro)
                )
                .close();
        }   
        if (this.hasInnerRadius()) {
            int ri := inner.getFlt();
            int si := Float:mulFlts(ri, Ring:S_FACTOR);
            p.moveFltTo(x, Float:addFlts(y, ri))
                .curveFltTo(
                    Float:subFlts(x, si), Float:addFlts(y, ri),
                    Float:subFlts(x, ri), Float:addFlts(y, si),
                    Float:subFlts(x, ri), y
                )
                .curveFltTo(
                    Float:subFlts(x, ri), Float:subFlts(y, si),
                    Float:subFlts(x, si), Float:subFlts(y, ri),
                    x, Float:subFlts(y, ri)
                )
                .curveFltTo(
                    Float:addFlts(x, si), Float:subFlts(y, ri),
                    Float:addFlts(x, ri), Float:subFlts(y, si),
                    Float:addFlts(x, ri), y
                )
                .curveFltTo(
                    Float:addFlts(x, ri), Float:addFlts(y, si),
                    Float:addFlts(x, si), Float:addFlts(y, ri),
                    x, Float:addFlts(y, ri)
                )
                .close();
        }
        
        return p;
    }

}
