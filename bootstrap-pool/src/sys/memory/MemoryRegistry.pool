/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace sys::memory;


class MemoryRegistry extends MemoryManager {
    
    // methods
    [MemoryInfo] allocate(int size) {
        int required = size + MemoryInfo:SIZEOF;
        
        // find splittable available memory
        MemoryInfo avail = this._findInfoByLen(available, required + MemoryInfo:SIZEOF);
        if (Address:compareAddress(avail.len, required) < 0) {
            return this.outOfAvailable(size);
        }
        
        // create embedded info
        MemoryInfo ret = Address:cast(avail.buf);
        ret.buf = avail.buf + MemoryInfo:SIZEOF;
        ret.len = size;
        ret.flags = MemoryInfo:FLAGS_USED;
        
        // mark as used
        this.registerUsedMemory(avail.buf, required);
        
        return ret;
    }
    
    [] free(MemoryInfo info) {
        // no static free available
        this.rt().err().printCString("bad static free").printNewline();
    }
    
    // registration
    [] registerAvailableMemory(int mem, int len) {
        if (len == 0) {
            return;
        }
        if (Address:compare(reserved, reserved.next) || Address:compare(used, used.next)) {
            this.rt().out().printCString("Ignore available ").printPtr(mem).printChar(':').printPtr(len).printNewline();
            return;
        }
        
        this._registerToList(available, mem, len, MemoryInfo:FLAGS_AVAILABLE);
    }
    
    [] registerReservedMemory(int mem, int len) {
        if (len == 0) {
            return;
        }
        
        this._removeFromList(available, mem, len);
        this._registerToList(reserved, mem, len, MemoryInfo:FLAGS_RESERVED);
    }
    
    [] registerUsedMemory(int mem, int len) {
        if (len == 0) {
            return;
        }
        
        this._removeFromList(available, mem, len);
        this._appendMemoryInfo(used.prev, this._nextNonEmbeddedInfo(mem, len, MemoryInfo:FLAGS_USED));
    }
    
    [] _registerToList(MemoryInfo list, int mem, int len, int flags) {
        MemoryInfo info = this._findInfoByPtr(list, mem);
        if (!Address:equals(info, list) && (Address:compareAddress((info.buf + info.len), mem) >= 0)) {
            // merge into prev
            if (Address:compareAddress((mem + len), (info.buf + info.len)) > 0) {
                info.len = mem + len - info.buf;
            }
        } else {
            // insert new
            this._appendMemoryInfo(info, this._nextNonEmbeddedInfo(mem, len, flags));
            info = info.next;
        }
        // merge with next
        while (!Address:equals(info.next, list) && (Address:compareAddress((info.buf + info.len), info.next.buf) >= 0)) {
            MemoryInfo merged = info.next;
            info.len = merged.buf + merged.len - info.buf;
            this._unlinkMemoryInfo(merged);
            merged.flags = 0;
        }
    }
    
    [] _removeFromList(MemoryInfo list, int mem, int len) {
        if (Address:equals(list, list.next)) {
            return;
        }
        
        int memEnd = mem + len;
        MemoryInfo first = this._findInfoByPtr(list, mem);
        MemoryInfo last = this._findInfoByPtr(list, memEnd);
        
        if (!Address:equals(first, last)) {
            // area covers multiple infos
    
            // remove fully covered infos    
            while(!Address:equals(first.next, last)) {
                MemoryInfo remove = first.next; 
                this._unlinkMemoryInfo(remove);
                remove.flags = 0;
            }
            
            if (!Address:equals(first, list)) {
                int firstEnd = first.buf + first.len;
                if (Address:compareAddress(firstEnd, mem) < 0) {
                    // area fully after first info
                } else if (first.buf == mem) {
                    // area fully covers first info
                    this._unlinkMemoryInfo(first);
                    first.flags = 0;
                } else {
                    // area is end of first info
                    first.len = mem - first.buf;
                }
            }
            
            int lastEnd = last.buf + last.len;
            if (Address:compareAddress(lastEnd, memEnd) <= 0) {
                // area fully covers last info
                this._unlinkMemoryInfo(last);
                last.flags = 0;
            } else {
                // area is begin of last info
                last.buf = memEnd;
                last.len = lastEnd - memEnd;
            }
        } else if (!Address:equals(first, list)) {
            int firstEnd = first.buf + first.len;
            if (Address:compareAddress(firstEnd, mem) < 0) {
                // area fully after first info
            } else if (first.buf == mem) {
                if (Address:compareAddress(first.len, len) <= 0) {
                    // area fully covers first info
                    this._unlinkMemoryInfo(first);
                    first.flags = 0;
                } else {
                    // area is begin of first info
                    first.buf = memEnd;
                    first.len = firstEnd - memEnd;
                }
            } else if (Address:compareAddress(firstEnd, memEnd) <= 0) {
                // area is end of first info
                first.len = mem - first.buf;
            } else {
                // area is inside of first info
                first.len = mem - first.buf;
                this._appendMemoryInfo(first, this._nextNonEmbeddedInfo(memEnd, firstEnd - memEnd, first.flags));
            }
        } else {
            // area fully before whole list
        }
    }
    
    // transfer
    [] transferTo(MemoryManager memoryManager) {
        // create buffer for non-embedded infos
        int nonEmbeddedCount = 3 + this._countNonEmbeddedInfos(reserved) + this._countNonEmbeddedInfos(used);
        // count available blocks, that are too small for embedded memory management
        MemoryInfo cur = available.next;
        while (!Address:equals(cur, available)) {
            if (Address:compareAddress(cur.len, MemoryInfo:SIZEOF) < 0) { nonEmbeddedCount++;}
            cur = cur.next;
        }
        
        memoryManager.initEmptyFromAllocator(this.allocator(), allocateIncreasing, nonEmbeddedCount);
    
        // transfer registered lists to memory manager
        this._transferMemoryList(available, memoryManager.available, memoryManager.nonEmbeddedInfos);
        this._transferMemoryList(reserved, memoryManager.reserved, memoryManager.nonEmbeddedInfos);
        this._transferMemoryList(used, memoryManager.used, memoryManager.nonEmbeddedInfos);
        
        // clear registry
        available.next = available.prev = available;
        reserved.next = reserved.prev = reserved;
        used.next = used.prev = used;
    }
    
    [int] _countNonEmbeddedInfos(MemoryInfo list) {
        int count = 0;
        MemoryInfo cur = list.next;
        while (!Address:equals(cur, list)) {
            int cannotEmbedInfo = (Address:compareAddress(cur.len, MemoryInfo:SIZEOF) < 0);
            MemoryInfo info = Address:cast(cur.buf);
            if (
                cannotEmbedInfo
                || ((info.flags / 0x10000) != MemoryInfo:MAGIC)                     // !isMemoryInfo
                || Address:compareAddress(info.buf, cur.buf + MemoryInfo:SIZEOF)    // !hasFollowingBuffer
            ) { count++; }
            cur = cur.next;
        }
        return count;
    }
    
    [] _transferMemoryList(MemoryInfo srcList, MemoryInfo destList, MemoryInfoPool nonEmbeddedInfos) {
        int isAvailable = Address:equals(srcList, available);
        
        MemoryInfo cur = srcList.next;
        while (!Address:equals(cur, srcList)) {
            int cannotEmbedInfo = (Address:compareAddress(cur.len, MemoryInfo:SIZEOF) < 0);
            MemoryInfo info = Address:cast(cur.buf);
            if (
                isAvailable
                || cannotEmbedInfo
                || ((info.flags / 0x10000) != MemoryInfo:MAGIC)                     // !isMemoryInfo
                || Address:compareAddress(info.buf, cur.buf + MemoryInfo:SIZEOF)    // !hasFollowingBuffer
            ) {
                if (!isAvailable || cannotEmbedInfo) {
                    // initialize info from buffer (reserved, used, small available)
                    info = Address:cast(nonEmbeddedInfos.elements + MemoryInfo:SIZEOF*(nonEmbeddedInfos.used++));
                } // else initialize embedded info (available)
                info.buf = cur.buf;
                info.len = cur.len;
                info.flags = cur.flags;
                info.owner = cur.owner;
            } // else use pre-initialized info as-is (used by allocate)
            this._appendMemoryInfo(destList.prev, info);
            cur = cur.next;
        }
    }
}
