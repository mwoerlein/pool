/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace pool::compiler;

use sys::core::anycollection::AnyIterator;
use sys::log::NullLogger;
use pool::storage::Mimetype;

class CompilerTest extends test::TestCase {

    [] runAll() {
        this.testSimpleClass();
        this.testStructs();
        this.testClasses();
        this.testMethodsInstructionsExpressions();
    }
    
    [int] testSimpleClass() {
        TestStorage t = this.newTestStorage("testSimpleClass");
        
        t.in("my::simple::Sample", Mimetype:POOL_SRC)
            .line("namespace my::simple;")
            .line("class Sample {")
            .line("")
            .line("    [int] one() { return 1; }")
            .line("    [int] two(__any__ obj) {")
            .line("        return '\\n';")
            .line("    }")
            .line("")
            .line("    [int] three(__any__ obj, cstring obj2) {")
            .line("        //return two(obj);")
            .line("        return 0x80000000;")
            .line("    }")
            .line("}")
        ;
        
        t.expect("my::simple::Sample", Mimetype:POOL_SRC)
            .line("namespace my::simple;")
            .line("")
            .line("")
            .line("class Sample {")
            .line("    ")
            .line("    // methods")
            .line("    [int] one() {")
            .line("        return 1;")
            .line("    }")
            .line("    ")
            .line("    [int] two(__any__ obj) {")
            .line("        return 10;")
            .line("    }")
            .line("    ")
            .line("    [int] three(__any__ obj, cstring obj2) {")
            .line("        return -2147483648;")
            .line("    }")
            .line("    ")
            .line("}")
        ;
        
        t.prepare("my::simple::Sample");
        
        return this.runTest(t);
    }

    [int] testStructs() {
        TestStorage t = this.newTestStorage("testStructs");
        
        t.in("structs::A", Mimetype:POOL_SRC)
            .line("namespace structs;")
            .line("use other::A as C;")
            .line("use other::D;")
            .line("struct A {")
            .line("    global int CONST := 1;")
            .line("    global cstring CSTRING := \"const\";")
            .line("    A a;")
            .line("    other::B b;")
            .line("    C c;")
            .line("    D d;")
            .line("    int x;")
            .line("    cstring y;")
            .line("}")
        ;
        t.in("other::A", Mimetype:POOL_SRC)
            .line("namespace other;")
            .line("struct A {")
            .line("    global int CONST := 1+1;")
            .line("    A a;")
            .line("}")
        ;
        t.in("other::B", Mimetype:POOL_SRC)
            .line("namespace other;")
            .line("struct B {")
            .line("}")
        ;
        t.in("other::D", Mimetype:POOL_SRC)
            .line("namespace other;")
            .line("class D {")
            .line("}")
        ;
        
        t.expect("structs::A", Mimetype:POOL_SRC)
            .line("namespace structs;")
            .line("")
            .line("use other::A as C;")
            .line("use other::D;")
            .line("")
            .line("struct A {")
            .line("    ")
            .line("    // constants")
            .line("    global int CONST := 1;")
            .line("    global cstring CSTRING := \"const\";")
            .line("    ")
            .line("    // variables")
            .line("    A a;")
            .line("    other::B b;")
            .line("    C c;")
            .line("    D d;")
            .line("    int x;")
            .line("    cstring y;")
            .line("}")
        ;
        
        t.prepare("structs::A");
        
        return this.runTest(t);
    }
    
    [int] testClasses() {
        TestStorage t = this.newTestStorage("testClasses");
        
        t.in("my::A", Mimetype:POOL_SRC)
            .line("namespace my;")
            .line("use other::C;")
            .line("class A extends B, C, other::D {")
            .line("    global cstring CSTRING := \"const\";")
            .line("    int a := 1;")
            .line("    int b = 1;")
            .line("    A a;")
            .line("    my::C c;")
            .line("    other::D d;")
            .line("    __any__ e;")
            .line("    __all__ f;")
            .line("}")
        ;
        t.in("my::B", Mimetype:POOL_SRC)
            .line("namespace my;")
            .line("class B extends my::C {")
            .line("}")
        ;
        t.in("my::C", Mimetype:POOL_SRC)
            .line("namespace my;")
            .line("class C {")
            .line("}")
        ;
        t.in("other::C", Mimetype:POOL_SRC)
            .line("namespace other;")
            .line("class C {")
            .line("}")
        ;
        t.in("other::D", Mimetype:POOL_SRC)
            .line("namespace other;")
            .line("class D {")
            .line("}")
        ;
        
        t.expect("my::A", Mimetype:POOL_SRC)
            .line("namespace my;")
            .line("")
            .line("use other::C;")
            .line("")
            .line("class A extends B, C, other::D {")
            .line("    ")
            .line("    // constants")
            .line("    global cstring CSTRING := \"const\";")
            .line("    int a := 1;")
            .line("    int b = 1;")
            .line("    ")
            .line("    // variables")
            .line("    A a;")
            .line("    my::C c;")
            .line("    other::D d;")
            .line("    __any__ e;")
            .line("    __all__ f;")
            .line("}")
        ;
        t.expect("my::B", Mimetype:POOL_SRC)
            .line("namespace my;")
            .line("")
            .line("")
            .line("class B extends my::C {")
            .line("}")
        ;        
        t.expect("my::C", Mimetype:POOL_SRC)
            .line("namespace my;")
            .line("")
            .line("")
            .line("class C {")
            .line("}")
        ;        
        t.prepare("my::A").prepare("my::B").prepare("my::C");
        
        return this.runTest(t);
    }

    [int] testMethodsInstructionsExpressions() {
        TestStorage t = this.newTestStorage("testMethodsInstructionsExpressions");
        
        t.in("my::A", Mimetype:POOL_SRC)
            .line("namespace my;")
            .line("class A extends B {")
            .line("    A a;")
            .line("    B b;")
            .line("    int i;")
            .line("    [A] ref(    B   b   ) { return a; }")
            .line("    [int] val() { return i; }")
            .line("    [int,int] bools() { return [true, false]; }")
            .line("    [] conditions() {")
            .line("        int i = 'a';")
            .line("        if (b && b.inc(0b11)) { return; }")
            .line("        if (!a && !b || !c) { i = i+ref( b ).a.i*a.ref(b).val()/val()-(7%B:v); } else { i = 1; }")
            .line("        if (i > 1 || i == +('\\r'-'\\n')/2) { }")
            .line("        else if (i < -1 && i != -this.i) { }")
            .line("        else if (i <= 1) { }")
            .line("        else { }")
            .line("    }")
            .line("    [] loops() {")
            .line("        int n := 5;")
            .line("        int i = val();")
            .line("        int s = 0;")
            .line("        int p = 0;")
            .line("        while (n > i++) { s+=i; p*=i; }")
            .line("        do {")
            .line("           [int x, int y, int z] := my::B:numbers(s, p);")
            .line("           [int l, int m, int n] = b.numbers(x, y);")
            .line("           int v = 0x1234;")
            .line("           { }")
            .line("           { v -= l /= m %= n = x; }")
            .line("           {")
            .line("             { l++; m--; ++n; }")
            .line("             l++; m--;")
            .line("             ++n;")
            .line("           }")
            .line("        } while (i-- >= 0);")
            .line("    }")
            .line("    [] pasm() {")
            .line("        A i = null;")
            .line("        __pasm__(<\"")
            .line("            addl %eax, %ecx")
            .line("            addl %ebx, %ecx")
            .line("        \">,{\"%eax\":this.a, \"%ebx\":b, \"%ecx\": i},{\"%ecx\":i});")
            .line("        __pasm__(\"pushl %eax\",{\"%eax\":i});")
            .line("        __pasm__(\"popl %eax\",{},{\"%eax\":i});")
            .line("    }")
            .line("}")
        ;
        
        t.in("my::B", Mimetype:POOL_SRC)
            .line("namespace my;")
            .line("class B {")
            .line("    global int v := -012;")
            .line("    [] empty() {}")
            .line("    abstract [int] inc(int a);")
            .line("    global [int,int,int] numbers(int a, int b) { return [1,a,a+b]; }")
            .line("    __naked__ [] halt_loop() { __pasm__(\"halt_loop: hlt; jmp halt_loop\"); }")
            .line("    __entry__ [int] entry(int argc, int argv) { return argc; }")
            .line("}")
        ;
        
        t.expect("my::A", Mimetype:POOL_SRC)
            .line("namespace my;")
            .line("")
            .line("")
            .line("class A extends B {")
            .line("    ")
            .line("    // variables")
            .line("    A a;")
            .line("    B b;")
            .line("    int i;")
            .line("    ")
            .line("    // methods")
            .line("    [A] ref(B b) {")
            .line("        return a;")
            .line("    }")
            .line("    ")
            .line("    [int] val() {")
            .line("        return i;")
            .line("    }")
            .line("    ")
            .line("    [int, int] bools() {")
            .line("        return [1, 0];")
            .line("    }")
            .line("    ")
            .line("    [] conditions() {")
            .line("        int i = 97;")
            .line("        if ((b && b.inc(3))) {")
            .line("            return;")
            .line("        }")
            .line("        if ((((!a) && (!b)) || (!c))) {")
            .line("            (i = ((i + ((ref(b).a.i * a.ref(b).val()) / val())) - (7 % B:v)));")
            .line("        } else {")
            .line("            (i = 1);")
            .line("        }")
            .line("        if (((i > 1) || (i == ((+(13 - 10)) / 2)))) {} else {")
            .line("            if (((i < -1) && (i != (-this.i)))) {} else {")
            .line("                if ((i <= 1)) {}")
            .line("            }")
            .line("        }")
            .line("    }")
            .line("    ")
            .line("    [] loops() {")
            .line("        int n := 5;")
            .line("        int i = val();")
            .line("        int s = 0;")
            .line("        int p = 0;")
            .line("        while ((n > (i++))) {")
            .line("            (s += i);")
            .line("            (p *= i);")
            .line("        }")
            .line("        do {")
            .line("            [int x, int y, int z] := my::B:numbers(s, p);")
            .line("            [int l, int m, int n] = b.numbers(x, y);")
            .line("            int v = 4660;")
            .line("            {}")
            .line("            {")
            .line("                (v -= (l /= (m %= (n = x))));")
            .line("            }")
            .line("            {")
            .line("                {")
            .line("                    (l++);")
            .line("                    (m--);")
            .line("                    (++n);")
            .line("                }")
            .line("                (l++);")
            .line("                (m--);")
            .line("                (++n);")
            .line("            }")
            .line("        } while (((i--) >= 0));")
            .line("    }")
            .line("    ")
            .line("    [] pasm() {")
            .line("        A i = null;")
            .line("        __pasm__(<\"")
            .line("            addl %eax, %ecx")
            .line("            addl %ebx, %ecx")
            .line("        \">, {\"%eax\": this.a, \"%ebx\": b, \"%ecx\": i}, {\"%ecx\": i});")
            .line("        __pasm__(<\"")
            .line("pushl %eax")
            .line("        \">, {\"%eax\": i}, {});")
            .line("        __pasm__(<\"")
            .line("popl %eax")
            .line("        \">, {}, {\"%eax\": i});")
            .line("    }")
            .line("    ")
            .line("}")
        ;
        t.expect("my::B", Mimetype:POOL_SRC)
            .line("namespace my;")
            .line("")
            .line("")
            .line("class B {")
            .line("    ")
            .line("    // constants")
            .line("    global int v := -10;")
            .line("    ")
            .line("    // methods")
            .line("    [] empty() {}")
            .line("    ")
            .line("    abstract [int] inc(int a);")
            .line("    ")
            .line("    global [int, int, int] numbers(int a, int b) {")
            .line("        return [1, a, (a + b)];")
            .line("    }")
            .line("    ")
            .line("    __naked__ [] halt_loop() {")
            .line("        __pasm__(<\"")
            .line("halt_loop: hlt; jmp halt_loop")
            .line("        \">, {}, {});")
            .line("    }")
            .line("    ")
            .line("    __entry__ [int] entry(int argc, int argv) {")
            .line("        return argc;")
            .line("    }")
            .line("    ")
            .line("}")
        ;        
        t.prepare("my::A").prepare("my::B");
        
        return this.runTest(t);
    }

    [TestStorage] newTestStorage(cstring name) {
        this.start(name);
        TestStorage storage = this.rt().createInstance(TestStorage:CLASSNAME);
        return storage.setName(name);
    }
    
    [int] runTest(TestStorage storage) {
        NullLogger l = this.rt().createInstance(NullLogger:CLASSNAME);
        Compiler c = this.rt().createInstance(Compiler:CLASSNAME);
        c.initLogger(l.logger())
            .addClassPath(storage.poolStorage())
            .setPrettyOutput(storage.poolStorage())
        ;
        if (c.hasErrors()) { return this.fail("Compiler initialization"); }
        
        {
            AnyIterator it = storage.prepares();
            while (it.hasNext()) { c.prepare(it.next()); }
            it.destroy();
        }
        if (c.hasErrors()) { return this.fail("Compiler preparation"); }
        
        c.compilePrepared();
        if (c.hasErrors()) { return this.fail("Compiler compilation"); }
        
        if (!storage.validateExpected()) { return this.fail("Pretty validation"); }

        c.destroy();
        l.destroy();
        return this.success();
    }

}
