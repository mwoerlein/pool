/*[meta]
mimetype = text/x-pool
author = Marc Woerlein <marc.woerlein@gmx.de>
version = 0.1.0
*/
namespace pool::compiler;

use sys::core::anycollection::AnyIterator;
use sys::log::NullLogger;
use pool::storage::Mimetype;

class CompilerTest extends test::TestCase {

    [] runAll() {
        this.testSimpleClass();
        this.testStructs();
        this.testClasses();
    }
    
    [int] testSimpleClass() {
        TestStorage t = this.newTestStorage("testSimpleClass");
        
        t.in("my::simple::Sample", Mimetype:POOL_SRC)
            .line("namespace my::simple;")
            .line("class Sample {")
            .line("")
            .line("    [int] one() { return 1; }")
            .line("    [int] two(__any__ obj) {")
            .line("        return '\\n';")
            .line("    }")
            .line("")
            .line("    [int] three(__any__ obj, cstring obj2) {")
            .line("        //return two(obj);")
            .line("        return 0x80000000;")
            .line("    }")
            .line("}")
        ;
        
        t.expect("my::simple::Sample", Mimetype:POOL_SRC)
            .line("namespace my::simple;")
            .line("")
            .line("")
            .line("class Sample {")
            .line("    ")
            .line("    // methods")
            .line("    [int] one() {")
            .line("        return 1;")
            .line("    }")
            .line("    ")
            .line("    [int] two(__any__ obj) {")
            .line("        return 10;")
            .line("    }")
            .line("    ")
            .line("    [int] three(__any__ obj, cstring obj2) {")
            .line("        return -2147483648;")
            .line("    }")
            .line("    ")
            .line("}")
        ;
        
        t.prepare("my::simple::Sample");
        
        return this.runTest(t);
    }

    [int] testStructs() {
        TestStorage t = this.newTestStorage("testStructs");
        
        t.in("structs::A", Mimetype:POOL_SRC)
            .line("namespace structs;")
            .line("use other::A as C;")
            .line("use other::D;")
            .line("struct A {")
            .line("    global int CONST := 1;")
            .line("    global cstring CSTRING := \"const\";")
            .line("    A a;")
            .line("    other::B b;")
            .line("    C c;")
            .line("    D d;")
            .line("    int x;")
            .line("    cstring y;")
            .line("}")
        ;
        t.in("other::A", Mimetype:POOL_SRC)
            .line("namespace other;")
            .line("struct A {")
            .line("    global int CONST := 1+1;")
            .line("    A a;")
            .line("}")
        ;
        t.in("other::B", Mimetype:POOL_SRC)
            .line("namespace other;")
            .line("struct B {")
            .line("}")
        ;
        t.in("other::D", Mimetype:POOL_SRC)
            .line("namespace other;")
            .line("class D {")
            .line("}")
        ;
        
        t.expect("structs::A", Mimetype:POOL_SRC)
            .line("namespace structs;")
            .line("")
            .line("use other::A as C;")
            .line("use other::D;")
            .line("")
            .line("struct A {")
            .line("    ")
            .line("    // constants")
            .line("    global int CONST := 1;")
            .line("    global cstring CSTRING := \"const\";")
            .line("    ")
            .line("    // variables")
            .line("    A a;")
            .line("    other::B b;")
            .line("    C c;")
            .line("    D d;")
            .line("    int x;")
            .line("    cstring y;")
            .line("}")
        ;
        
        t.prepare("structs::A");
        
        return this.runTest(t);
    }
    
    [int] testClasses() {
        TestStorage t = this.newTestStorage("testClasses");
        
        t.in("my::A", Mimetype:POOL_SRC)
            .line("namespace my;")
            .line("use other::C;")
            .line("class A extends B, C, other::D {")
            .line("    global cstring CSTRING := \"const\";")
            .line("    int a := 1;")
            .line("    int b = 1;")
            .line("    A a;")
            .line("    my::C c;")
            .line("    other::D d;")
            .line("    __any__ e;")
            .line("    __all__ f;")
            .line("}")
        ;
        t.in("my::B", Mimetype:POOL_SRC)
            .line("namespace my;")
            .line("class B extends my::C {")
            .line("}")
        ;
        t.in("my::C", Mimetype:POOL_SRC)
            .line("namespace my;")
            .line("class C {")
            .line("}")
        ;
        t.in("other::C", Mimetype:POOL_SRC)
            .line("namespace other;")
            .line("class C {")
            .line("}")
        ;
        t.in("other::D", Mimetype:POOL_SRC)
            .line("namespace other;")
            .line("class D {")
            .line("}")
        ;
        
        t.expect("my::A", Mimetype:POOL_SRC)
            .line("namespace my;")
            .line("")
            .line("use other::C;")
            .line("")
            .line("class A extends B, C, other::D {")
            .line("    ")
            .line("    // constants")
            .line("    global cstring CSTRING := \"const\";")
            .line("    int a := 1;")
            .line("    int b = 1;")
            .line("    ")
            .line("    // variables")
            .line("    A a;")
            .line("    my::C c;")
            .line("    other::D d;")
            .line("    __any__ e;")
            .line("    __all__ f;")
            .line("}")
        ;
        t.expect("my::B", Mimetype:POOL_SRC)
            .line("namespace my;")
            .line("")
            .line("")
            .line("class B extends my::C {")
            .line("}")
        ;        
        t.expect("my::C", Mimetype:POOL_SRC)
            .line("namespace my;")
            .line("")
            .line("")
            .line("class C {")
            .line("}")
        ;        
        t.prepare("my::A").prepare("my::B").prepare("my::C");
        
        return this.runTest(t);
    }

    [TestStorage] newTestStorage(cstring name) {
        this.start(name);
        TestStorage storage = this.rt().createInstance(TestStorage:CLASSNAME);
        return storage.setName(name);
    }
    
    [int] runTest(TestStorage storage) {
        NullLogger l = this.rt().createInstance(NullLogger:CLASSNAME);
        Compiler c = this.rt().createInstance(Compiler:CLASSNAME);
        c.initLogger(l.logger())
            .addClassPath(storage.poolStorage())
            .setPrettyOutput(storage.poolStorage())
        ;
        if (c.hasErrors()) { return this.fail("Compiler initialization"); }
        
        {
            AnyIterator it = storage.prepares();
            while (it.hasNext()) { c.prepare(it.next()); }
            it.destroy();
        }
        if (c.hasErrors()) { return this.fail("Compiler preparation"); }
        
        c.compilePrepared();
        if (c.hasErrors()) { return this.fail("Compiler compilation"); }
        
        if (!storage.validateExpected()) { return this.fail("Pretty validation"); }

        c.destroy();
        l.destroy();
        return this.success();
    }

}
